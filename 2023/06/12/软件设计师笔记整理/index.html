<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="软件设计师" />
    <meta name="hexo-theme-A4" content="v1.6.9" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Lau | </title>

    
        
            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/reset.css">

            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/markdown.css">

            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/fonts.css">
 
            <!--注意：首页既不是post也不是page-->
            
        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <style>
        :root {
            --waline-theme-color: #fec591; 
            --waline-color: #fec591; 
            --waline-border-color: #fec591; 
            --waline-white: #fec591; 
            --waline-bgcolor-light: #005454;  
        }
        body {
            color: #fec591;
            background: #005454;
        }
        .post-md code {
            background: black;
            color: white; 
        }
        .year-font-color {
            color: #fec591 !important;
        }
        .wl-card span.wl-nick {
            color: #fec591; 
        }
        .wl-card .wl-badge {
            border: 1px solid #fec591;
            color: #fec591; 
        }
        .wl-btn {
            border: 1px solid #fec591; 
            color:  #fec591;  
        }
        .wl-btn.primary {
            color: #005454; 
        }
        .wl-header label {
            color: #fec591;
        }
        a {
            color: #fec591;
        }

        .post-md a {
            color: #fec591;
        }

        .nav li a {
            color: #fec591;
        }

        .archive-main a:link {
            color: #fec591;
        }
        .archive-main a:visited {
            color: #fec591; 
        }

        .archive li span {
            color: #fec591;
        }

        .post-main-title {
            color: #fec591;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #fec591;
        }

        [data-waline] p {
            color: #fec591;
        }
        [data-waline] a {
            color: #fec591;
        } 
        .wl-sort li.active {
            color: #fec591;
        }

        .wl-card .wl-meta>span {
            background: #005454;
        }

        .paper {
            background: #005454;
        }

        .index-main {
            background: #005454;
        }

        .paper-main {
            background: #005454;
        }

        .wl-panel {
            background: #005454;
        }

        .archive li:nth-child(odd) {
            background: #005454;
            ;
        }

        .archive li:nth-child(even) {
            background: #005454;
        }

        .post-md>table tr:nth-child(odd) td {
            background: #005454;
        }

        .post-md>table tr:nth-child(even) td {
            background: #005454;
        }
    </style>

    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Lau</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            软件设计师
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8"><span class="post-toc-text">信息安全</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E5%85%B6%E4%BB%96%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF"><span class="post-toc-text">信息安全&gt;其他网络安全控制技术</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E5%85%B6%E5%AE%83"><span class="post-toc-text">信息安全&gt;其它</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E4%B8%8E%E6%9C%A8%E9%A9%AC"><span class="post-toc-text">信息安全&gt;计算机病毒与木马</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="post-toc-text">信息安全&gt;对称加密与非对称加密</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="post-toc-text">信息安全&gt;数字证书</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E4%BF%A1%E6%81%AF%E6%91%98%E8%A6%81%E4%B8%8E%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="post-toc-text">信息安全&gt;信息摘要与数字签名</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%88%86%E7%BA%A7"><span class="post-toc-text">信息安全&gt;系统安全分级</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-lt-%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB"><span class="post-toc-text">信息安全&lt;网络攻击</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF"><span class="post-toc-text">信息安全&gt;防火墙技术</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-gt-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE"><span class="post-toc-text">信息安全&gt;网络安全协议</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="post-toc-text">计算机组成与体系结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E6%8A%80%E6%9C%AF"><span class="post-toc-text">计算机组成与体系结构&gt;输入&#x2F;输出技术</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="post-toc-text">计算机组成与体系结构&gt;计算机基本工作原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="post-toc-text">计算机组成与体系结构&gt;寻址方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-Cache"><span class="post-toc-text">计算机组成与体系结构&gt;Cache</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E6%A0%87"><span class="post-toc-text">计算机组成与体系结构&gt;计算机指标</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-CPU%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%88%E8%BF%90%E7%AE%97%E5%99%A8%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89"><span class="post-toc-text">计算机组成与体系结构&gt;CPU的组成（运算器与控制器）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="post-toc-text">计算机组成与体系结构&gt;海明校验码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-CISC%E5%92%8CRISC"><span class="post-toc-text">计算机组成与体系结构&gt;CISC和RISC</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E5%B1%82%E6%AC%A1%E5%8C%96%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB"><span class="post-toc-text">计算机组成与体系结构&gt;层次化存储体系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F"><span class="post-toc-text">计算机组成与体系结构&gt;总线系统</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E4%B8%BB%E5%AD%98%E7%BC%96%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="post-toc-text">计算机组成与体系结构&gt;主存编址计算</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-gt-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="post-toc-text">计算机组成与体系结构&gt;逻辑运算</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="post-toc-text">软件工程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E9%9D%99%E6%80%81%E6%B5%8B%E8%AF%95"><span class="post-toc-text">软件工程&gt;静态测试</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E7%B1%BB%E5%9B%BE"><span class="post-toc-text">软件工程&gt;类图</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8"><span class="post-toc-text">软件工程&gt;数据流图与数据字典</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="post-toc-text">软件工程&gt;软件开发方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E9%A3%8E%E9%99%A9%E8%AF%86%E5%88%AB%E4%B8%8E%E9%A3%8E%E9%99%A9%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">软件工程&gt;风险识别与风险类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81"><span class="post-toc-text">软件工程&gt;软件质量保证</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="post-toc-text">软件工程&gt;软件测试相关概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E9%9C%80%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB"><span class="post-toc-text">软件工程&gt;需求分析相关概念及需求的分类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">软件工程&gt;开发模型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="post-toc-text">软件工程&gt;架构设计</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-McCabe%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="post-toc-text">软件工程&gt;McCabe复杂度计算</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%BB%BB%E5%8A%A1"><span class="post-toc-text">软件工程&gt;结构化设计任务</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3"><span class="post-toc-text">软件工程&gt;软件文档</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B"><span class="post-toc-text">软件工程&gt;软件过程改进</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="post-toc-text">软件工程&gt;模块结构图</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="post-toc-text">软件工程&gt;模块设计原则</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">软件工程&gt;软件维护类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="post-toc-text">软件工程&gt;软件维护相关概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E8%AF%84%E5%AE%A1"><span class="post-toc-text">软件工程&gt;软件评审</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AF"><span class="post-toc-text">软件工程&gt;软件容错技术</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E9%9C%80%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB"><span class="post-toc-text">软件工程&gt;需求的分类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E5%86%85%E8%81%9A%E6%80%A7"><span class="post-toc-text">软件工程&gt;内聚性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%80%A6%E5%90%88%E6%80%A7"><span class="post-toc-text">软件工程&gt;耦合性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="post-toc-text">软件工程&gt;概要设计与详细设计</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="post-toc-text">软件工程&gt;软件工程设计原则</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="post-toc-text">软件工程&gt;黑盒测试</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-gt-%E5%85%B6%E4%BB%96"><span class="post-toc-text">软件工程&gt;其他</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="post-toc-text">数据结构与算法基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88"><span class="post-toc-text">数据结构与算法基础&gt;队列与栈</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">数据结构与算法基础&gt;字符串</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7"><span class="post-toc-text">数据结构与算法基础&gt;树与二叉树的特性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E5%85%B6%E4%BB%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="post-toc-text">数据结构与算法基础&gt;其他二叉树</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8"><span class="post-toc-text">数据结构与算法基础&gt;顺序表与链表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="post-toc-text">数据结构与算法基础&gt;最短路径</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><span class="post-toc-text">数据结构与算法基础&gt;散列表（哈希）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="post-toc-text">数据结构与算法基础&gt;图的拓扑排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E6%8E%92%E5%BA%8F"><span class="post-toc-text">数据结构与算法基础&gt;排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-gt-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="post-toc-text">数据结构与算法基础&gt;迭代和递归算法</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F"><span class="post-toc-text">数据库系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-gt-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="post-toc-text">数据库系统&gt;分布式数据库</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-gt-%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post-toc-text">数据库系统&gt;规范化理论基本概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-gt-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="post-toc-text">数据库系统&gt;关系代数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-gt-%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C"><span class="post-toc-text">数据库系统&gt;并发操作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-gt-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="post-toc-text">数据库系统&gt;数据库三级模式结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-gt-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="post-toc-text">数据库系统&gt;数据库设计过程</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="post-toc-text">操作系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-gt-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="post-toc-text">操作系统&gt;操作系统的作用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-gt-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="post-toc-text">操作系统&gt;页式存储</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-gt-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="post-toc-text">操作系统&gt;线程的概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-gt-%E4%BD%8D%E8%A7%86%E5%9B%BE"><span class="post-toc-text">操作系统&gt;位视图</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-gt-%E6%AD%BB%E9%94%81%E8%B5%84%E6%BA%90%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="post-toc-text">操作系统&gt;死锁资源数计算</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-gt-%E7%89%B9%E6%AE%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="post-toc-text">操作系统&gt;特殊的操作系统</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-gt-I-x2F-O%E7%AE%A1%E7%90%86%E8%AE%BE%E5%A4%87"><span class="post-toc-text">操作系统&gt;I&#x2F;O管理设备</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">面向对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post-toc-text">面向对象&gt;面向对象的基本概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="post-toc-text">面向对象&gt;面向对象设计原则</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9B%BE"><span class="post-toc-text">面向对象&gt;设计模式的图</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="post-toc-text">面向对象&gt;设计模式的分类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="post-toc-text">面向对象&gt;设计模式的应用场景</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="post-toc-text">面向对象&gt;软件开发过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-UML%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="post-toc-text">面向对象&gt;UML图的定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-UML%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB"><span class="post-toc-text">面向对象&gt;UML图的分类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-UML%E5%9B%BE%E7%9A%84%E5%9B%BE%E7%A4%BA%EF%BC%9B"><span class="post-toc-text">面向对象&gt;UML图的图示；</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-UML%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="post-toc-text">面向对象&gt;UML图中的关系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E5%8F%91%E5%90%84%E9%98%B6%E6%AE%B5%E5%88%92%E5%88%86%E5%8F%8A%E4%BB%BB%E5%8A%A1"><span class="post-toc-text">面向对象&gt;面向对象开发各阶段划分及任务</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-gt-%E5%85%B6%E5%AE%83"><span class="post-toc-text">面向对象&gt;其它</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><span class="post-toc-text">程序设计语言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-gt-%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="post-toc-text">程序设计语言&gt;有限自动机</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1-gt-%E7%BC%96%E8%AF%91%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="post-toc-text">程序与语言设计&gt;编译器工作过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-gt-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="post-toc-text">程序设计语言&gt;程序语言基本知识</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-gt-%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A"><span class="post-toc-text">程序设计语言&gt;编译与解释</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-gt-%E9%94%99%E8%AF%AF%E7%AE%A1%E7%90%86"><span class="post-toc-text">程序设计语言&gt;错误管理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-gt-%E5%A4%9A%E7%A7%8D%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="post-toc-text">程序设计语言&gt;多种程序语言特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-gt-%E6%96%87%E6%B3%95"><span class="post-toc-text">程序设计语言&gt;文法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80-gt-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81"><span class="post-toc-text">程序设计语言&gt;中间代码</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="post-toc-text">计算机网络</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-%E5%85%B6%E4%BB%96"><span class="post-toc-text">计算机网络&gt;其他</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-%E5%8D%8F%E8%AE%AE%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87"><span class="post-toc-text">计算机网络&gt;协议应用提升</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E4%B8%8E%E8%B7%AF%E7%94%B1%E6%B1%87%E8%81%9A"><span class="post-toc-text">计算机网络&gt;子网划分与路由汇聚</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="post-toc-text">计算机网络&gt;常用命令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-HTML%E8%AF%AD%E8%A8%80"><span class="post-toc-text">计算机网络&gt;HTML语言</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE"><span class="post-toc-text">计算机网络&gt;路由配置</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-TCP%E4%B8%8EUDP"><span class="post-toc-text">计算机网络&gt;TCP与UDP</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-%E5%B8%B8%E8%A7%81TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="post-toc-text">计算机网络&gt;常见TCP&#x2F;IP协议基础</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-URL"><span class="post-toc-text">计算机网络&gt;URL</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE-1"><span class="post-toc-text">计算机网络&gt;路由配置</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-gt-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF"><span class="post-toc-text">计算机网络&gt;网络接入技术</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"><span class="post-toc-text">项目管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-gt-%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86"><span class="post-toc-text">项目管理&gt;风险管理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-gt-Gant%E5%9B%BE%E4%B8%8EPert%E5%9B%BE"><span class="post-toc-text">项目管理&gt;Gant图与Pert图</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-gt-%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86"><span class="post-toc-text">项目管理&gt;成本管理</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80"><span class="post-toc-text">多媒体基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80-gt-%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post-toc-text">多媒体基础&gt;多媒体技术基本概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80-gt-MPEG%E5%A3%B0%E9%9F%B3%E4%BF%A1%E6%81%AF%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E6%8A%80%E6%9C%AF"><span class="post-toc-text">多媒体基础&gt;MPEG声音信息压缩编码技术</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80-gt-%E5%AA%92%E4%BD%93%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%88%E6%98%BE%E7%A4%BA%E5%AA%92%E4%BD%93%EF%BC%89"><span class="post-toc-text">多媒体基础&gt;媒体的种类（显示媒体）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80-gt-%E5%B8%B8%E8%A7%81%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E5%87%86"><span class="post-toc-text">多媒体基础&gt;常见多媒体标准</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96"><span class="post-toc-text">法律法规与标准化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96-gt-%E4%BF%9D%E6%8A%A4%E6%9C%9F%E9%99%90"><span class="post-toc-text">法律法规与标准化&gt;保护期限</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96-gt-%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83"><span class="post-toc-text">法律法规与标准化&gt;知识产权</span></a></li></ol></li></ol></li></ol>
        
        <pre><code>     ***&lt;u&gt;备考软件设计师的时候在希赛网上做的选择题的错题解析&lt;/u&gt;***	[每日一练](https://wangxiao.xisaiwang.com/tiku2/list-dp136.html)
</code></pre>
<h2 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h2><h4 id="信息安全-gt-其他网络安全控制技术"><a href="#信息安全-gt-其他网络安全控制技术" class="headerlink" title="信息安全&gt;其他网络安全控制技术"></a>信息安全&gt;其他网络安全控制技术</h4><p>部署防火墙：防火墙技术是通过有机结合各类用于安全管理和筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术，并不能有效的防范病毒。</p>
<p>安装并及时升级防病毒软件：针对于防病毒软件本身就是防范病毒最有效最直接的方式。</p>
<p>漏洞扫描为一种安全防护策略。</p>
<h4 id="信息安全-gt-其它"><a href="#信息安全-gt-其它" class="headerlink" title="信息安全&gt;其它"></a>信息安全&gt;其它</h4><p>加强内防内控主要通过访问授权、安全策略、安全检查与行为审计等多种安全手段的综合应用来实现。终端接入的数量影响的是网络的规模、数据交换的性能，不是内防内控关注的重点。</p>
<h4 id="信息安全-gt-计算机病毒与木马"><a href="#信息安全-gt-计算机病毒与木马" class="headerlink" title="信息安全&gt;计算机病毒与木马"></a>信息安全&gt;计算机病毒与木马</h4><p>计算机病毒具有隐蔽性、传染性、潜伏性、触发性和破坏性等特点</p>
<p>“冲击波”病毒是一种蠕虫类型的病毒。在进行网络传播时，利用了Windows操作系统的RPC漏洞。</p>
<p>震网（Stuxnet）是一种蠕虫病毒，是第一个专门定向攻击真实世界中基础设施的“蠕虫”病毒。</p>
<p>引导区病毒破坏的是引导盘、文件目录等，宏病毒破坏的是OFFICE文件相关，木马的作用一般强调控制操作。</p>
<p>计算机病毒的分类方法有许多种，按照最通用的区分方式，即根据其感染的途径以及采用的技术区分，计算机病毒可分为文件型计算机病毒、引导型计算机病毒、宏病毒和目录型计算机病毒。</p>
<ul>
<li>文件型计算机病毒感染可执行文件（包括EXE和COM文件）。</li>
<li>引导型计算机病毒影响软盘或因硬盘的引导扇区。</li>
<li>目录型计算机病毒能够修改硬盘上存储的所有文件的地址。</li>
<li>宏病毒感染的对象是使用某些程序创建的文本文档、数据库、电子表格等文件从文件名可以看出。</li>
</ul>
<p>Macro.Melissa是一种宏病毒</p>
<h4 id="信息安全-gt-对称加密与非对称加密"><a href="#信息安全-gt-对称加密与非对称加密" class="headerlink" title="信息安全&gt;对称加密与非对称加密"></a>信息安全&gt;对称加密与非对称加密</h4><p>对于非对称加密又称为公开密钥加密，而共享密钥加密指对称加密。常见的对称加密算法有：DES、三重DES、RC-5、IDEA、AES</p>
<p>对大量明文进行加密，考虑效率问题，一般采用对称加密。</p>
<p>RSA是非对称加密算法。</p>
<p>SHA-1和MD5属于信息摘要算法，不能用来加密数据。</p>
<p>MD5是一种摘要算法，经过一系列处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<h4 id="信息安全-gt-数字证书"><a href="#信息安全-gt-数字证书" class="headerlink" title="信息安全&gt;数字证书"></a>信息安全&gt;数字证书</h4><p>数字证书是由权威机构——CA证书授权（Certificate Authority）中心发行的，能提供在Internet上进行身份验证的一种权威性电子文档，人们可以在因特网交往中用它来证明自己的身份和识别对方的身份。</p>
<p>数字证书包含版本、序列号、签名算法标识符、签发人姓名、有效期、主体名和主体公钥信息等并附有CA的签名，用户获取网站的数字证书后通过验证CA的签名来确认数字证书的有效性，从而验证网站的真伪。</p>
<p>在用户与网站进行安全通信时，用户发送数据时使用网站的公钥（从数字证书中获得）加密，收到数据时使用网站的公钥验证网站的数字签名，网站利用自身的私钥对发送的信息签名和对收到的消息解密。</p>
<p>最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。其中证书授权中心的数字签名是用它自己的私钥完成的，而它的公钥也是公开的，大家可以通过它的公钥来验证该证书是否是某证书授权中心发行的，以达到验证数字证书的真实性。</p>
<h4 id="信息安全-gt-信息摘要与数字签名"><a href="#信息安全-gt-信息摘要与数字签名" class="headerlink" title="信息安全&gt;信息摘要与数字签名"></a>信息安全&gt;信息摘要与数字签名</h4><p>数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息相比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<p>数字签名是个加密的过程，数字签名验证是个解密的过程。保证信息传输的完整性、发送者的身份认证、防止交易中抵赖发生。</p>
<p>公钥体系即非对称加密体系，其密钥分为公钥和私钥。一般公钥用于加密，而私钥用于解密。公钥一般是公开的，大家都知道的，适合用于认证；而私钥只有密钥拥有者自己知道，可用于签名。</p>
<h4 id="信息安全-gt-系统安全分级"><a href="#信息安全-gt-系统安全分级" class="headerlink" title="信息安全&gt;系统安全分级"></a>信息安全&gt;系统安全分级</h4><p>网络安全体系设计是逻辑设计工作的重要内容之一，数据库容灾属于系统安全和应用安全考虑范畴。</p>
<h4 id="信息安全-lt-网络攻击"><a href="#信息安全-lt-网络攻击" class="headerlink" title="信息安全&lt;网络攻击"></a>信息安全&lt;网络攻击</h4><p>ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，它通过伪造网关ARP报文与你通信，而使得你的数据包无法发送到真正的网关，从而造成网络无法跨网通信。</p>
<p>重放攻击（Replay Attacks）又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接受过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的地方进行</p>
<h4 id="信息安全-gt-防火墙技术"><a href="#信息安全-gt-防火墙技术" class="headerlink" title="信息安全&gt;防火墙技术"></a>信息安全&gt;防火墙技术</h4><p>包过滤防火墙对数据包的过滤依据包括源IP地址、源端口号、目标IP地址和目标端口号。</p>
<h4 id="信息安全-gt-网络安全协议"><a href="#信息安全-gt-网络安全协议" class="headerlink" title="信息安全&gt;网络安全协议"></a>信息安全&gt;网络安全协议</h4><p>TLS安全传输层协议用于在两个通信应用程序之间提供保密性和数据完整性。</p>
<p>TCP是可靠的传输层协议，与安全无关。</p>
<p>SSH为Secure Shell的缩写，由IETF的网络工作小组（Network Working Group）所指定；SSH为建立在应用层和传输层基础上的安全协议。SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。</p>
<p>TFTP（Trivial File Transfer Protocol，简单文件传输协议）是TCP&#x2F;IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不负责、开销不大的文件传输服务。</p>
<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<h2 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h2><h4 id="计算机组成与体系结构-gt-输入-x2F-输出技术"><a href="#计算机组成与体系结构-gt-输入-x2F-输出技术" class="headerlink" title="计算机组成与体系结构&gt;输入&#x2F;输出技术"></a>计算机组成与体系结构&gt;输入&#x2F;输出技术</h4><p>直接主存存取（Direct Memory Access ，DMA）是指数据在主存与I&#x2F;O设备间（即主存与外设之间）直接成块传送。</p>
<p>DMA是直接内存存取，传送数据的时间只与内存相关，与CPU的时间无关。采用DMA方式传送数据时，每传送一个数据都需要占用一个存储周期。</p>
<p>按照是否可以被屏蔽，可将中断分为两大类：不可屏蔽中断（又叫非屏蔽中断）和可屏蔽中断。不可屏蔽中断源一旦提出请求，CPU必须无条件响应，而对可屏蔽中断源的请求，CPU可以响应，也可以不响应。典型的非屏蔽中断源的例子是电源掉电，一旦出现，必须立即无条件响应，否则进行其他任何工作都是没有意义的。典型的可屏蔽中断源的例子是打印机终端，CPU对打印机中断请求的响应可以快一些，也可以慢一些，因为让打印机等待是完全可以的。对于软中断，它不受中断允许标志位（IF位）的影响，所以属于非屏蔽中断范畴。</p>
<h4 id="计算机组成与体系结构-gt-计算机基本工作原理"><a href="#计算机组成与体系结构-gt-计算机基本工作原理" class="headerlink" title="计算机组成与体系结构&gt;计算机基本工作原理"></a>计算机组成与体系结构&gt;计算机基本工作原理</h4><p>CPU中的程序计数器PC用于保存要执行的指令的地址，访问内存时，需要将内存地址送入存储器地址寄存器MAR中，向内存写入数据时，待写入的数据要先放入数据寄存器MUR中。程序中的指令一般放在内存中，要执行时，首先要访问内存取得指令并保存在指令寄存器IR中。计算机中指令的执行过程一般分为取指令、分析指令并获取操作数、运算和传送结果等阶段，每条指令被执行时都要经过这几个阶段。</p>
<h4 id="计算机组成与体系结构-gt-寻址方式"><a href="#计算机组成与体系结构-gt-寻址方式" class="headerlink" title="计算机组成与体系结构&gt;寻址方式"></a>计算机组成与体系结构&gt;寻址方式</h4><p>寻址方式查询速度：</p>
<p>立即寻址：操作数直接在指令中&gt;寄存器寻址：操作数存放在寄存器中&gt;直接寻址：指令中存放操作数的地址</p>
<p>立即寻址的特点是：指令的地址字段指出的不是操作数的地址，而是操作数的本身；直接寻址的特点是：在指令格式的地址字段中直接指出操作数在内存的地址；寄存器寻址的特点是：指令中给出的操作数地址不是内存的地址单元号，而是通用寄存器的编号（当操作数不放在内存中，而是放在CPU的通用寄存器中时，可采用寄存器寻址方式）；寄存器间接寻址方式与寄存器寻址方式的区别在于：指令格式中操作数地址所指向的寄存器中存放的内容不是操作数，而是操作数的地址，通过该地址可在内存中找到操作数；相对寻址的特点是：把程序计数器PC的内容加上指令格式中的形式地址来形成操作数的有效地址。</p>
<p>寻址是指寻找操作数的地址或下一条将要执行的指令地址。数据和指令一般都需要存放在一些存储器的存储单元中，存储器对这些存储单元进行编号，这些编号就是数据和指令的地址，如果在应用中需要用到这些数据或指令时，就用过它们的地址到存储器中去寻找，这就是寻址。</p>
<p>假如某主机的主存容量可达1MB，而指令中的地址码字段最长仅16位，只能直接访问主存的一小部分，而无法访问到整个主存空间，而采用不同的寻址方式可以实现对整个主存空间的访问。就是在字长很长的大型机中（地址码字段足够长），即使指令中能够拿出足够的位数来作为访问整个主存空间的地址，但为了灵活、方便地编制程序，也需要对地址进行必要的变换。</p>
<h4 id="计算机组成与体系结构-gt-Cache"><a href="#计算机组成与体系结构-gt-Cache" class="headerlink" title="计算机组成与体系结构&gt;Cache"></a>计算机组成与体系结构&gt;Cache</h4><p>全相联映像块冲突最小，其次为组相联映像，直接映像块冲突最大。</p>
<p>高速缓存Cache有如下特点：它位于CPU和主存之间，有硬件实现；容量小，一般在几KB到几MB之间；速度一般比主存快5到10倍，由快速半导体存储器制成；其内容是主存内容的副本，对程序员来说是透明的；Cache即可存放程序又可存放数据。</p>
<p>Cache主要由两部分组成：控制部分和Cacahe存储器部分。Cache存储器部分用来存放主存的部份拷贝（备份）。控制部分的功能是：判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址。未命中时，若是读取操作，则从主存中读取数据，并按照确定的替换原则把该数据写入Cache存储器中；若是写入操作，则将数据写入主存即可。</p>
<p>Cache与主存地址映射是由硬件完成，与操作系统、存储管理系统、存储管理软件、程序员无关。</p>
<h4 id="计算机组成与体系结构-gt-计算机指标"><a href="#计算机组成与体系结构-gt-计算机指标" class="headerlink" title="计算机组成与体系结构&gt;计算机指标"></a>计算机组成与体系结构&gt;计算机指标</h4><p>在计算机当中，时钟频率时其时钟周期的倒数，表示时间的度量。</p>
<p>总线宽度是指总线的线数，即数据信号并行传输的能力，指单位时间内传输的数据总量。</p>
<p>吞吐量：指在给定的时间内，系统所能处理的任务的数量。</p>
<p>响应时间：指系统对请求做出响应的时间。</p>
<p>容量：存储器所能存储的全部信息量称为该存储器的容量。</p>
<p>负载：负载能力一般指的是系统能承受的最大任务数。</p>
<h4 id="计算机组成与体系结构-gt-CPU的组成（运算器与控制器）"><a href="#计算机组成与体系结构-gt-CPU的组成（运算器与控制器）" class="headerlink" title="计算机组成与体系结构&gt;CPU的组成（运算器与控制器）"></a>计算机组成与体系结构&gt;CPU的组成（运算器与控制器）</h4><p>指令寄存器（IR）用来保存当前正在执行的指令。当执行一条指令时，先把它从内存取到数据寄存器（DR）中，然后再传送至IR。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器（ID）就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。</p>
<p>指令寄存器对用户是完全透明的。</p>
<p>地址寄存器（AR）用来保存当前CPU所访问的内存单元的地址。由于在内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读&#x2F;写操作完成为止。</p>
<p>为了保证程序指令能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。</p>
<p>状态寄存器用来存放计算结果的标志信息，如进位标志、溢出标志等，程序员可以利用状态标志进行判断和跳转。</p>
<p>通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果，程序员可以利用通用寄存器存取数据。</p>
<p>程序计数器PC：存储下一条要执行的地址。</p>
<p>指令寄存器IR：存储即将执行的指令。</p>
<p>主存地址寄存器MAR：用来保存当前CPU所访问的内存单元的地址。</p>
<p>状态条件寄存器PSW：存状态标志与控制标志。</p>
<p>运算器：</p>
<ol>
<li>算术逻辑单元</li>
<li>累加寄存器</li>
<li>数据缓冲寄存器</li>
<li>状态条件寄存器</li>
</ol>
<p>控制器：</p>
<ol>
<li>程序计数器PC</li>
<li>指令寄存器IR</li>
<li>指令译码器</li>
<li>时序部件</li>
</ol>
<h4 id="计算机组成与体系结构-gt-海明校验码"><a href="#计算机组成与体系结构-gt-海明校验码" class="headerlink" title="计算机组成与体系结构&gt;海明校验码"></a>计算机组成与体系结构&gt;海明校验码</h4><p>一个编码系统中任意两个编码（码字）之间不同的二进数位数称为这两个码字的码距，而整个编码系统中任意两个码字的最小距离就是该编码系统的码距，为了使一个系统能检查和纠正一个差错，码间最小距离至少是3。</p>
<p>循环冗余校验码（CRC）编码方式是在k位信息码后再拼接r位的校验码，形成长度为n位的编码，其特点是检错能力极强且开销小，易于用编码器及检测电路实现。</p>
<h4 id="计算机组成与体系结构-gt-CISC和RISC"><a href="#计算机组成与体系结构-gt-CISC和RISC" class="headerlink" title="计算机组成与体系结构&gt;CISC和RISC"></a>计算机组成与体系结构&gt;CISC和RISC</h4><p>CISC是复杂指令系统计算机，RISC是精简指令系统计算机。</p>
<p>RISC的风格是强调计算机结构的简单性和高效性。RISC设计是从足够的不可缺少的指令集开始的。它的速度比那些具有传统复杂指令组计算机结构的机器快得多，而且RISC机由于其较简洁的设计，较易使用，故具有更短地研制开发周期。RISC与CISC相比，指令种类更精简，指令长度基本保持一致，寻址方式比较单一，一般使用寄存器寻址，研发周期更短，指令格式等长，容易用硬布线逻辑实现，适合高效的流水线操作。</p>
<h4 id="计算机组成与体系结构-gt-层次化存储体系"><a href="#计算机组成与体系结构-gt-层次化存储体系" class="headerlink" title="计算机组成与体系结构&gt;层次化存储体系"></a>计算机组成与体系结构&gt;层次化存储体系</h4><p>虚拟存储器是一个容量非常大的存储器的逻辑模型，不是任何实际的物理存储器。它借助于磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。</p>
<p>虚拟存储器指的是主存-外存层次。它以透明的方式给用户提供了一个比实际主存空间大得多的程序地址空间。此时的程序的逻辑地址称为虚拟地址（虚地址），程序的逻辑地址空间称为虚拟地址空间。物理地址（实地址）适用于访问主存的地址。设CPU地址总线的宽度为m位，那么物理地址空间的大小用2^m来表示。</p>
<p>相联存储器是一种按内容进行存储和访问的存储器。</p>
<p>DRAM：动态随机存取存储器，又叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介，通过周期性刷新来保持数据的存储器件，断电丢失。</p>
<p>SRAM：静态随机存取存储器。所谓的“静态“，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。</p>
<p>FLASH：闪存，特性介于EPROM和EEPROM之间，类似于EEPROM，也可以使用电信号进行信息的擦除操作。</p>
<p>EEPROM：电擦除可编程的只读存储器，与EPROM相似，EEPROM中的内容即既可以读出，也可以进行改写。</p>
<h4 id="计算机组成与体系结构-gt-总线系统"><a href="#计算机组成与体系结构-gt-总线系统" class="headerlink" title="计算机组成与体系结构&gt;总线系统"></a>计算机组成与体系结构&gt;总线系统</h4><p>CPU与其他部件交换数据时，用数据总线传输数据。数据总线宽度指同时传送的二进制位数，内存容量、指令系统中的指令数量和寄存器的位数与数据总线的宽度无关。数据总线宽度越大，单位时间内能进出CPU的数据就越多，系统的运算速度越快。</p>
<p>PCI总线：是目前微型机上广泛采用的内总线，采用并行传输方式。</p>
<p>SCSI总线：小型计算机系统接口上一条并行外总线，广泛用于连接软硬磁盘、光盘、扫描仪等。</p>
<h4 id="计算机组成与体系结构-gt-主存编址计算"><a href="#计算机组成与体系结构-gt-主存编址计算" class="headerlink" title="计算机组成与体系结构&gt;主存编址计算"></a>计算机组成与体系结构&gt;主存编址计算</h4><p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_%E4%B8%BB%E5%AD%98%E7%BC%96%E5%9D%80%E8%AE%A1%E7%AE%97.png"></p>
<p>运行时为名字分配存储空间的过程称为绑定。静态数据区用于存放一对一的绑定且编译时就可确定存储空间大小的数据，栈用于存放一对多的绑定且与活动同生存期的绑定；堆用于存储由程序语句动态生成和撤销的数据。</p>
<p>程序运行时，需要将程序代码（机器指令序列）和代码所操作的数据加载至内存。指令代码加载至代码区，数据则根据绑定关系可能位于静态数据区、栈或堆区。</p>
<p>立即数寻址方式是指指令所需的操作数由指令的地址码部分直接给出，其特点是取指令时间同时取出操作数，以提高指令的执行速度。</p>
<h4 id="计算机组成与体系结构-gt-逻辑运算"><a href="#计算机组成与体系结构-gt-逻辑运算" class="headerlink" title="计算机组成与体系结构&gt;逻辑运算"></a>计算机组成与体系结构&gt;逻辑运算</h4><p>移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：&lt;&lt;（左移）、&gt;&gt;(带符号右移)和&gt;&gt;&gt;无符号右移，算术左移、算术右移、逻辑右移的规则与上述移位运算符一一对应。</p>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h4 id="软件工程-gt-静态测试"><a href="#软件工程-gt-静态测试" class="headerlink" title="软件工程&gt;静态测试"></a>软件工程&gt;静态测试</h4><p>三明治测试策略的优点是自顶向下与自底向上两种方式优点的综合，可以较早地验证主要的控制和判断点且较早的验证了底层模块。同时由于可以两端向中间发展，所以效率也是比较高的，<u>且运用了一定的技巧</u>，能够减少桩模块和驱动模块的开发。</p>
<p>在单元测试开始时，应该对通过所有被测模块的数据流进行测试。</p>
<ol>
<li>输入参数是否与形式参数一致。</li>
<li>调用模块的实参与调用模块形参是否一致。</li>
<li>全局变量在各模块中的定义和用法是否一致。</li>
<li>外部输入、输出等。</li>
</ol>
<p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p>
<h4 id="软件工程-gt-类图"><a href="#软件工程-gt-类图" class="headerlink" title="软件工程&gt;类图"></a>软件工程&gt;类图</h4><p>类图是描述类的构成以其多个类之间存在的静态关系的一种工具。对于一个系统中的两个类而言，它们要么不存在任何关系，要么存在is-like-a的关系或has-a的关系。其中is-like-a表示两个类之间的继承关系，has-a表示两个类之间存在的整体与部分形式的组成关系，即其中一个类的数据成员的类型是另外一个类，而这种关系在UML中采用聚合关系表示。</p>
<h4 id="软件工程-gt-数据流图与数据字典"><a href="#软件工程-gt-数据流图与数据字典" class="headerlink" title="软件工程&gt;数据流图与数据字典"></a>软件工程&gt;数据流图与数据字典</h4><p>数据字典是指对数据的数据项、数据结构、数据流、数据存储、处理逻辑、外部实体等进行定义和描述，其目的是对数据流程图中的各个元素作出详细的说明，使用数据字典为简单的建模项目。其条目有数据流、数据项、数据存储、基本加工等。</p>
<p>数据流图主要由实体、数据存储、处理过程和数据流四部分组成。在顶层数据流图中，将系统描述成一个处理过程，而其它的是与该处理过程相关的输入输出流，因此顶层数据流图描述了系统的输入与输出。</p>
<p>结构化语言：形式语言精确，但不易被理解，自然语言易理解，但它不精确，可能产生二义性。结构化语言取长补短，她是在自然语言基础上加了一些限定，使用有限的词汇和有限的语句来描述加工逻辑，结构化语言是介于自然语言（汉语或英语）和形式化语言之间的一种半形式化语言。</p>
<p>程序流程图：描述模块或程序执行过程的历史最久、流行最广的一种图形表示方法。</p>
<p>NS图：是支持结构化程序设计方法而产生的一种描述工具。</p>
<p>决策树：一种适合于描述加工中具有多个策略且每个策略和若干条件有关的逻辑功能的图形工具。</p>
<h4 id="软件工程-gt-软件开发方法"><a href="#软件工程-gt-软件开发方法" class="headerlink" title="软件工程&gt;软件开发方法"></a>软件工程&gt;软件开发方法</h4><p>面向数据流的设计是以需求分析阶段产生的数据流图为基础，按一定的步骤映射成软件结构，因此又称结构化设计。该方法由美国IBM公司L.Constantine和E.Yourdon等人于1974年提出，与结构化分析（SA）衔接，构成了完整的结构分析与设计技术，是目前使用最广泛的软件设计方法之一。</p>
<p>各种软件系统，不管DFD如何庞大和复杂，一般可分为变换型和事务型，一个软件系统既可以只有一种数据流类型，也可以是两种数据流类型。在结构化设计中，可以将数据流映射为软件系统的模块结构，不同类型的数据流有不同的映射方法。</p>
<h4 id="软件工程-gt-风险识别与风险类型"><a href="#软件工程-gt-风险识别与风险类型" class="headerlink" title="软件工程&gt;风险识别与风险类型"></a>软件工程&gt;风险识别与风险类型</h4><p>客户特性是指与客户的素质以及开发者和客户定期通信的能力相关的风险。</p>
<p>过程定义是指与软件过程被定义的程度以及它们被开发组织所遵守的程序相关的风险。</p>
<p>开发环境是指与用以构建产品的工具的可用性及质量相关的风险。</p>
<p>构建技术是指与待开发软件的复杂性及系统所包含技术的”新奇性“相关的风险</p>
<h4 id="软件工程-gt-软件质量保证"><a href="#软件工程-gt-软件质量保证" class="headerlink" title="软件工程&gt;软件质量保证"></a>软件工程&gt;软件质量保证</h4><p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81.png"></p>
<h4 id="软件工程-gt-软件测试相关概念"><a href="#软件工程-gt-软件测试相关概念" class="headerlink" title="软件工程&gt;软件测试相关概念"></a>软件工程&gt;软件测试相关概念</h4><p>测试用例要包括欲测试的功能、应输入的数据和预期的输出结果。测试用例应覆盖有效合理输入，也要包含不合理、失效的输入。</p>
<p>确认测试首先要进行有效性测试以及软件配置审查，然后进行验收测试和安装测试。其中有效性测试，就是在模拟环境下，通过黑盒测试检验所开发的软件是否与需求规格说明书一致。</p>
<p>软件测试的目的是为了发现尽可能多的缺陷。</p>
<h4 id="软件工程-gt-需求分析相关概念及需求的分类"><a href="#软件工程-gt-需求分析相关概念及需求的分类" class="headerlink" title="软件工程&gt;需求分析相关概念及需求的分类"></a>软件工程&gt;需求分析相关概念及需求的分类</h4><p>结构化方法的分析结果由以下几部分组成：一套分层的数据流图、一本数据词典、一组小说明（也称加工逻辑说明）、补充材料。</p>
<p>结构图不属于结构化分析的输出</p>
<p>数据流图摆脱系统的物理内容，在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分。</p>
<p>软件需求中对软件产品的响应时间、吞吐量、价格等属性的要求都属于非功能性需求。</p>
<h4 id="软件工程-gt-开发模型"><a href="#软件工程-gt-开发模型" class="headerlink" title="软件工程&gt;开发模型"></a>软件工程&gt;开发模型</h4><p>瀑布模型严格遵循软件生命周期各阶段的固定顺序：计划、分析、设计、编程、测试和维护，上一阶段完成后才能进入到下一阶段。瀑布模型的优点是：可强迫开发人员采用规范的方法；严格规定了各阶段必须提交的文档；要求每个阶段结束后，都要进行严格的评审。但瀑布模型过于理想化，而且缺乏灵活性，无法在开发过程中逐渐明确用户难以确切表达或一时难以想到的需求。<strong>瀑布模型比较适合于需求明确，对交付时间有严格要求的开发。</strong></p>
<p>瀑布模型（Waterfall Model）是一个项目开发架构，开发过程是通过设计一系列阶段顺序展开的，从系统需求分析开始知道产品发布和维护，每个阶段都会产生循环反馈，因此，如果有信息未被覆盖或者发现了问题，那么最好”返回“上一个阶段并进行适当的修改，项目开发过程从一个阶段“流动”到下一个阶段，这也是瀑布模型名称的由来。</p>
<p>原型模型基于这样一种客观事实：并非所有的需求在系统开发之前都能准确地说明和定义。因此，它不追求也不可能要求对需求的严格定义，而是采用了动态定义需求的方法。<strong>原型模型适用于需求不明确的开发环境。</strong></p>
<p>螺旋模型综合了瀑布模型和演化模型的优点，还增加了风险分析。螺旋模型包含了四个方面的活动：制订计划、风险分析、实施工程、客户评估。采用螺旋模型时，软件开发沿着螺旋线自内向外旋转，每转一圈都要对风险进行识别和分析并采取相应的对策。<strong>螺旋模型比较适合大规模的开发，它对风险控制有很高的要求。</strong></p>
<p><strong>喷泉模型主要用于描述面向对象的开发过程，喷泉一词体现了面向对象开发过程的迭代和无间隙特征。</strong>迭代意味着模型中的开发活动常常需要多次重复，每次重复都会增加或明确一些目标系统的性质，但却不是对先前工作结果的本质性改动。无间隙是指在开发活动（如分析、设计、编程）之间不存在明显的边界，而是允许各开发活动交叉、迭代地进行</p>
<p>Rational Unified Process是软件工程的过程。它提供了开发组织中分派任务和责任的纪律化方法。它的目标是在可预见的日程和预算前提下，确保满足最终用户需求的高质量产品。</p>
<p>统一过程模型是一种“用例驱动，以体系结构为核心，迭代及增量”的软件过程框架，由UML方法和工具支持。</p>
<p>RUP把一个项目分为四个不同的阶段：</p>
<p>构思阶段：包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型。</p>
<p>细化阶段：包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示。</p>
<p>构建阶段：将设计转化为实现，并进行集成和测试。</p>
<p>移交阶段：将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善。</p>
<p>每个迭代有五个核心工作流：</p>
<ol>
<li>捕获系统应该做什么的需求工作流；</li>
<li>精化和结构化需求的分析工作流；</li>
<li>在系统结构内实现需求的设计工作流；</li>
<li>构造软件的实习工作流；</li>
<li>验证是否如期那样工作的测试工作流。</li>
</ol>
<p>极限编程（XP）是敏捷开发的典型方法之一，是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方法，它由价值观、原则、实践和行为4个部分组成。其中4大价值观为沟通、简单性、反馈和勇气。</p>
<h4 id="软件工程-gt-架构设计"><a href="#软件工程-gt-架构设计" class="headerlink" title="软件工程&gt;架构设计"></a>软件工程&gt;架构设计</h4><p>MVC模式，即模型-视图-控制（Model-View-Controller)模式，它实际上是一种架构模式，是为那些需要同样的数据提供多个视图的应用程序而设计的，它很好地体现了数据层与表示层的分离。</p>
<p>MVC把应用程序分为3种对象类型。</p>
<p>模型：应用问题域中包含的抽象领域知识。</p>
<p>视图：将应用问题域中包含的抽象领域知识呈现给用户的方法，一个模型可以用于多个视图。</p>
<p>控制器：用户界面对用户输入的相应方式。</p>
<h4 id="软件工程-gt-McCabe复杂度计算"><a href="#软件工程-gt-McCabe复杂度计算" class="headerlink" title="软件工程&gt;McCabe复杂度计算"></a>软件工程&gt;McCabe复杂度计算</h4><p>代码行数度量法以程序的总代码行数作为程序复杂性的度量值。</p>
<p>McCabe度量法先画出程序图，然后采用公式V(G)&#x3D;m-n+2计算环路复杂度，其中m是有向弧的数量，n是节点的数量。</p>
<h4 id="软件工程-gt-结构化设计任务"><a href="#软件工程-gt-结构化设计任务" class="headerlink" title="软件工程&gt;结构化设计任务"></a>软件工程&gt;结构化设计任务</h4><p>体系结构设计：定义软件系统各主要部分之间的关系。</p>
<p>数据设计：基于E-R图确定软件涉及的文件系统的结构及数据库的表结构。</p>
<p>接口设计（人机界面设计）：软件内部，软件和操作系统间以及软件和人之间如何通信。</p>
<p>过程设计：系统结构部件转换成软件的过程描述。确定软件各个组成部分内的算法及内部数据结构，并选定某种过程的表达形式来描述各种算法。</p>
<p>软件涉及必须依据对软件的需求来进行，结构化分析的结果为结构化设计提供了最基本的输入信息。从分析到设计往往经历以下流程：</p>
<ol>
<li><p>研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口。</p>
</li>
<li><p>根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型。针对两种不同的类型分别进行分析处理。</p>
</li>
<li><p>由数据流图推导出系统的初始结构图。</p>
</li>
<li><p>利用一些启发式原则来改变系统的初始结构图，直到得到符合要求的结构图为止。</p>
</li>
<li><p>根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计或数据文件的设计。</p>
</li>
<li><p>在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。</p>
</li>
</ol>
<p>所以接口设计的主要依据是数据流图，接口设计的任务主要是描述软件与外部环境之间的交互关系，软件内模块之间的调用关系。</p>
<h4 id="软件工程-gt-软件文档"><a href="#软件工程-gt-软件文档" class="headerlink" title="软件工程&gt;软件文档"></a>软件工程&gt;软件文档</h4><p>文档是开发中的重要工具，对开发有较大意义。</p>
<p>软件文档在软件开发过程和运行维护中起着重要作用，比如文件可以提高软件开发过程的能见度，提高开发效率，便于协调软件的开发、使用和维护，另外也可以对软件的运维和培训提供相关信息，便于各类相关人员进行交流。按照文档产生和适用范围，软件文件可分为开发文档、管理文档和用户文档，其中开发文档产生于软件开发过程，是前一阶段的工作成果体现，也是后一阶段工作的依据，用户文档是为用户准备的软件使用、操作和维护的资料。</p>
<p>概要设计说明书主要说明系统的功能分配、模块划分、程序的总体结构、I&#x2F;O及接口设计、运行设计、数据结构设计和错误处理设计等内容。</p>
<p>详细设计说明书着重描述每个模块是如何实现的。</p>
<p>用户使用手册帮助用户了解软件的使用，需要描述软件的功能、性能和用户界面。</p>
<p>用户需求说明书是开发人员和用户经过充分沟通后对软件需求的共同理解，主要说明软件的功能、性能和运行环境等内容。</p>
<p>用户与系统分析人员交流所使用的文档可以包括以下：</p>
<p>可行性研究报告：可行性研究报告是从事一种经济活动（投资）之前，双方要从经济、技术、生产、供销知道社会各种环境、法律等各种因素进行具体调查、研究、分析，确定有利和不利的因素、项目是否可行，估计成功率大小、经济效益和社会效果程度，为决策者和主管机关审批的上报文件。是需求分析和客户人员之间交流所使用或参考的文档。</p>
<p>总体规划报告：至少市场&#x2F;客户、新产品、人（引进、培养）、设备、成本等方面包括，也是需求分析和客户人员之间交流所使用或参考的文档。</p>
<p>项目开发计划：是指通过使用项目其他专项计划过程所产生的结果（即项目的各种专项计划），运用整合和综合平衡的方法，制定出用于指导项目实施和管理的整合性、综合性、全局性、协调统一的整合计划文件。是对需求分析和客户人员交流所必要的文档。</p>
<h4 id="软件工程-gt-软件过程改进"><a href="#软件工程-gt-软件过程改进" class="headerlink" title="软件工程&gt;软件过程改进"></a>软件工程&gt;软件过程改进</h4><p>软件过程改进&#x2F;过程改进（SPI）帮助软件企业对其软件（制作）过程的改变进行计划、（措施）制定以及实施。它的实施对象就是软件企业的软件过程，也就是软件产品的生产过程，当然也包括软件维护之类的维护过程，而对于其他的过程并不关注。在软件过程改进时，如果发现问题，需转化为软件过程改进计划。软件过程改进不是一次性就能达到最终目标，而是需要反复进行的，每次改进会经历四个步骤：评估、计划、改进和监控。</p>
<p>软件过程改进的框架包括：过程改进基础设施，过程改进进程图，软件过程评估方法和软件过程改进计划。</p>
<p><strong>能力成熟度模型（CMM）</strong> </p>
<p>CMM是对软件组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进其软件过程，软件组织的能力经过这些阶段逐步提高。</p>
<p>CMM将软件过程改进分为以下5个成熟度级别：</p>
<ol>
<li><p>初始级（Initial）</p>
<p>软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的成功完全依赖个人的努力和英雄式核心人物的作用。</p>
</li>
<li><p>可重复级（Repeatable）</p>
<p>建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。</p>
</li>
<li><p>已定义级（Defined）</p>
<p>管理和工程两方面的软件构成已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</p>
</li>
<li><p>已管理级（Managed）</p>
<p>制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制。</p>
</li>
<li><p>优化级（Optimized）</p>
<p>加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</p>
<p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B.png"></p>
</li>
</ol>
<p><strong>能力成熟度模型集成（CMMI）连续式模型</strong></p>
<p>能力等级可以独立地应用于任何单独的过程域。任何一个能力等级都必须满足比它等级低的能力等级的所有准则。对各能力等级的含义简述如下：</p>
<ul>
<li>CL0（未完成的）：过程域未执行或未得到CL1中定义的所有目标。</li>
<li>CL1（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。</li>
<li>CL2（已管理的）：其共性目标是集中于已管理的的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审。</li>
<li>CL3（已定义级的）：其共性目标集中于已定义的过程的制度化。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。</li>
<li>CL4（定量管理的）：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。</li>
<li>CL5（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。</li>
</ul>
<p>软件设计师教程P247</p>
<h4 id="软件工程-gt-模块结构图"><a href="#软件工程-gt-模块结构图" class="headerlink" title="软件工程&gt;模块结构图"></a>软件工程&gt;模块结构图</h4><p>模块结构图由模块、调用、数据、控制信息和转接符号5种基本符号组成。</p>
<p>模块：这里所说的模块通常指用一个名字就可以调用的一段程序语句。在模块结构图中用矩形表示。</p>
<p>调用：模块结构图中箭头总是由调用模块指向被调用模块。</p>
<p>数据：当一个模块调用另一个模块时，调用模块可以把数据传送到被调用模块提供处理，而被调用模块又可以将处理的结果送回到调用模块。在模块之间传送的数据，使用与调用箭头平行的带空心圆的箭头表示，并在旁边标上数据名。</p>
<p>控制信息：在模块间有时必须传送某些控制信息。控制信息与数据的主要区别是前者只反映数据的某种状态，不必进行处理。</p>
<p>控制信息与控制成分表并不等价。软设在程序设计语言中提到语言的控制成分。控制成分指明语言允许表述的控制结构，程序员使用控制成分来构造程序中的控制逻辑。理论上已经证明，可计算问题的程序都可以用顺序、选择和循环这3种控制结构来描述。</p>
<p>转接符号：当模块结构图在一张纸上画不下，需要转接到另一张纸上，或者为了避免图上线条交叉时，都可以使用转接符号，圆圈内加上标号。</p>
<h4 id="软件工程-gt-模块设计原则"><a href="#软件工程-gt-模块设计原则" class="headerlink" title="软件工程&gt;模块设计原则"></a>软件工程&gt;模块设计原则</h4><p>模块的作用范围是指受该模块内部一个判定影响的所有模块集合，只有某一模块内含有依赖于该判定的操作，那么该模块就在该判定的作用范围内。</p>
<p>模块的控制范围包括该模块本身以及该模块的所有下属模块。控制范围完全取决于系统的结构，与模板本身的功能并没有多大关系。在系统设计中，对于模块的作用范围和控制范围有两条原则：</p>
<ol>
<li>对于任何一个判断，其作用范围应该是这个判断所在模块的控制范围的一个子集。换言之，所有受判断影响的模块应该从属于做出判断的那个模块。</li>
<li>受模块M判定影响的模块，最好局限于模块M本身或其直接下属模块。</li>
</ol>
<p><strong>模块化设计要求高内聚、低耦合。</strong></p>
<p>在结构化设计中，系统由多个逻辑上相对独立的模块组成，在模块划分时需要遵循如下原则：</p>
<ol>
<li><strong>模块的大小要适中。</strong>系统分解时需要考虑模块的规模，过大的模块可能导致系统分解不充分，其内部可能包括不同类型的功能，需要进一步划分，尽量使得各个模块的功能单一；过小的模块将导致系统的复杂度增加，模块之间的调用过于频繁，反而降低了模块的独立性。一般来说，一个模块的大小使其实现代码在1<del>2页纸之内，或者其实现代码行数在50</del>200行之间，这种规模的模块易于实现和维护。</li>
<li><strong>模块的扇入和扇出要合理。</strong>一个模块的扇出是指该模块直接调用的下级模块的个数；扇出大表示模块的复杂度高，需要控制和协调过多的下级模块。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的控制模块；扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。一个模块的扇入是指直接调用该模块的上级模块的个数；扇入大表示模块的复用程度高。设计良好的软件结构通常顶层扇出比较大，中间扇出较少，底层模块则有大扇入。一般来说，系统的平均扇入和扇出系数为3或4，不应该超过7，否则会增大出错的概率。</li>
<li><strong>深度和宽度适当。</strong>深度表示软件结构中模块的层数，如果层数过多，则应考虑是否有些模块设计过于简单，看能否适当合并。宽度是软件结构中同一个层次上的模块总数的最大值，一般来说，宽度越大系统越复杂，对宽度影响最大的因素是模块的扇出。在系统设计时，需要权衡系统的深度和宽度，尽量降低系统的复杂性，减少实施过程的难度，提高开发和维护的效率。</li>
</ol>
<p>模块的扇入指模块直接上级模块的个数。模块的直属下级模块个数即为模块的扇出。</p>
<p>一个模块的作用范围（或称影响范围）指受该模块内一个判定影响的所有模块的集合。</p>
<p>一个模块的控制范围指模块本身以及其所有下属模块（直接或间接从属它的模块）的集合。</p>
<p>一个模块的作用范围应在其控制范围之内，且判定所在的模块应在其影响的模块在层次上尽量靠近。如果在设计过程中，发现模块作用范围不在其控制范围之内，可以用“上移判点“或”下移受判断影响的模块，将它下移到判断所在模块的控制范围内”的方法加以改进。</p>
<h4 id="软件工程-gt-软件维护类型"><a href="#软件工程-gt-软件维护类型" class="headerlink" title="软件工程&gt;软件维护类型"></a>软件工程&gt;软件维护类型</h4><ul>
<li>改正性维护也叫正确性维护，是指在使用过程中发现了隐蔽的错误后，为了诊断和改正这些隐蔽错误而修改软件的活动。</li>
<li>适应性维护是指为了适应变化了的环境而修改软件的活动。</li>
<li>完善性维护是指为了扩充或完善原有软件的功能或性能而修改软件的活动。</li>
<li>预防性维护是指为了提高软件的可维护性和可靠性、为未来的进一步改进打下基础而修改软件的活动。</li>
</ul>
<p>软件维护的内容一般包括准确性维护、适应性维护、完善性维护和预防性维护。</p>
<p>正确性维护是指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误。</p>
<p>适应性维护是指使应用软件适应信息技术变化和管理需求变化而进行的修改。</p>
<p>完善性维护主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特性。</p>
<p>预防性维护是指为了适应未来的软硬件环境的变化，主动增加预防性的新功能，以使应用系统适应各类变化而不被淘汰。</p>
<h4 id="软件工程-gt-软件维护相关概念"><a href="#软件工程-gt-软件维护相关概念" class="headerlink" title="软件工程&gt;软件维护相关概念"></a>软件工程&gt;软件维护相关概念</h4><p>辅助软件维护过程中的活动的软件称为“软件维护工具”，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有：</p>
<ol>
<li>版本控制工具</li>
<li>文档分析工具</li>
<li>开发信息库工具</li>
<li>逆向工程工具</li>
<li>再工程工具</li>
<li>配置管理支持工具</li>
</ol>
<h4 id="软件工程-gt-软件评审"><a href="#软件工程-gt-软件评审" class="headerlink" title="软件工程&gt;软件评审"></a>软件工程&gt;软件评审</h4><p>设计质量评审的内容主要有：软件需求规格说明、软件可靠性、软件是否具有可修改性、可扩充性、可互换性、可移植性、可测试性和可重用性及软件性能的实现情况等</p>
<h4 id="软件工程-gt-软件容错技术"><a href="#软件工程-gt-软件容错技术" class="headerlink" title="软件工程&gt;软件容错技术"></a>软件工程&gt;软件容错技术</h4><p>冗余技术一般包括时间冗余、信息冗余、结构冗余和冗余附加技术，其中结构冗余按照工作方法可以分为静态、动态和混合冗余。</p>
<h4 id="软件工程-gt-需求的分类"><a href="#软件工程-gt-需求的分类" class="headerlink" title="软件工程&gt;需求的分类"></a>软件工程&gt;需求的分类</h4><p>软件需求中对软件产品的响应时间、吞吐量、价格等属性的要求都属于非功能性需求。</p>
<h4 id="软件工程-gt-内聚性"><a href="#软件工程-gt-内聚性" class="headerlink" title="软件工程&gt;内聚性"></a>软件工程&gt;内聚性</h4><table>
<thead>
<tr>
<th align="left">内聚类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">功能内聚</td>
<td>完成一个单一功能，各个部分协同工作，缺一不可</td>
</tr>
<tr>
<td align="left">顺序内聚</td>
<td>处理元素相关，而且必须顺序执行</td>
</tr>
<tr>
<td align="left">通信内聚</td>
<td>所有处理元素集中在一个数据结构的区域上</td>
</tr>
<tr>
<td align="left">过程内聚</td>
<td>处理元素相关，而且必须按特定的次序执行</td>
</tr>
<tr>
<td align="left">瞬时内聚（时间内聚）</td>
<td>所包含的任务必须在同一时间间隔内执行</td>
</tr>
<tr>
<td align="left">逻辑内聚</td>
<td>完成逻辑上相关的一组任务</td>
</tr>
<tr>
<td align="left">偶然内聚（巧合内聚）</td>
<td>完成一组没有关系或松散关系的任务</td>
</tr>
</tbody></table>
<h4 id="软件工程-gt-耦合性"><a href="#软件工程-gt-耦合性" class="headerlink" title="软件工程&gt;耦合性"></a>软件工程&gt;耦合性</h4><p>模块的耦合度表现了模块之间相互关联的程度</p>
<p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E8%80%A6%E5%90%88%E6%80%A7.png"></p>
<p>非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</p>
<p>数据耦合：一个模块访问另一个模块时，彼此之间是通过简单数据参数（不是控制参数、公共数据结构或外部变量）来交换输入、输出信息的。</p>
<p>标记耦合：一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，而不是简单的变量。其实传递的是这个数据结构的地址；</p>
<p>控制耦合：如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。</p>
<p>外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</p>
<p>公共耦合：若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。</p>
<p>内容耦合：如果发生下列情形，两个模块之间就发生了内容耦合。</p>
<ol>
<li>一个模块直接访问另一个模块的内部数据；</li>
<li>一个模块不通过正常入口转到另一个模块内部；</li>
<li>两个模块有一部分程序代码重叠（只可能出现在汇编语言中）；</li>
<li>一个模块有多个入口</li>
</ol>
<h4 id="软件工程-gt-概要设计与详细设计"><a href="#软件工程-gt-概要设计与详细设计" class="headerlink" title="软件工程&gt;概要设计与详细设计"></a>软件工程&gt;概要设计与详细设计</h4><p>软件详细设计阶段的主要任务包括：对模块内的数据结构进行设计；对数据库进行物理设计；对每个模块进行详细的算法设计；代码设计、输入&#x2F;输出设计、用户界面设计等其他设计。</p>
<p>软件概要设计阶段的主要任务包括：软件系统总体结构设计，将系统划分为模块；确定每个模块的功能；确定模块之间的调用关系；确定模块之间的接口，即模块之间传递的信息；评价模块结构的质量；数据结构及数据库设计。</p>
<h4 id="软件工程-gt-软件工程设计原则"><a href="#软件工程-gt-软件工程设计原则" class="headerlink" title="软件工程&gt;软件工程设计原则"></a>软件工程&gt;软件工程设计原则</h4><p>改写代码仅使其结构上更紧凑，并不能提高执行效率问题。</p>
<h4 id="软件工程-gt-黑盒测试"><a href="#软件工程-gt-黑盒测试" class="headerlink" title="软件工程&gt;黑盒测试"></a>软件工程&gt;黑盒测试</h4><p>测试用例编写一般原则：</p>
<ol>
<li>设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；</li>
<li>设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。</li>
</ol>
<h4 id="软件工程-gt-其他"><a href="#软件工程-gt-其他" class="headerlink" title="软件工程&gt;其他"></a>软件工程&gt;其他</h4><p>传入模块：从下属模块取得数据，经处理再将其传送给上级模块。</p>
<p>传出模块：从上级模块取得数据，经处理再将其传送给下属模块。</p>
<p>变换模块：从上级模块取得数据，进行特定的处理，转换成其他形式，再传送给上级模块。</p>
<h2 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a>数据结构与算法基础</h2><h4 id="数据结构与算法基础-gt-队列与栈"><a href="#数据结构与算法基础-gt-队列与栈" class="headerlink" title="数据结构与算法基础&gt;队列与栈"></a>数据结构与算法基础&gt;队列与栈</h4><p>队列：先进先出</p>
<p>栈：后进先出</p>
<p>因为栈的操作是先进后出，因此无论是入栈还是出栈，都只对栈顶元素操作，而在单链表中用头指针作为栈顶指针，因此无论是出栈还是入栈，都只需要对头指针指向的栈顶指针操作即可，不需要遍历链表。</p>
<p>对于循环队列，求队头元素的指针的计算公式为：(rear-len+1+m)%M</p>
<p>求队列中元素个数公式为：（rear-fear+M)%M。其中fear表示队列的队头指针。</p>
<h4 id="数据结构与算法基础-gt-字符串"><a href="#数据结构与算法基础-gt-字符串" class="headerlink" title="数据结构与算法基础&gt;字符串"></a>数据结构与算法基础&gt;字符串</h4><p>空格也是一个字符，所以包含空格的字符串不能称为空串。</p>
<p>字符串是线性结构。</p>
<p>在串比较、求子串、串连接、串替换运算中，除了串替换外，其他运算都不会改变串中的内容，因此，在链表存储方式下进行串替换最不方便。</p>
<h4 id="数据结构与算法基础-gt-树与二叉树的特性"><a href="#数据结构与算法基础-gt-树与二叉树的特性" class="headerlink" title="数据结构与算法基础&gt;树与二叉树的特性"></a>数据结构与算法基础&gt;树与二叉树的特性</h4><p>哈夫曼树又称为最优二叉树，是一类带权路径长度最短的树。若深度为k的二叉树有2^k-1个节点，则称其为满二叉树。可以对满二叉树中的节点进行连续编号：约定编号从根节点起，自上而下、自左至右依次对应。深度为k、有n个结点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中编号从1至n的节点一一对应时，称之为完全二叉树。</p>
<p>二叉排序树又称二叉查找树，它或者是一棵空树，或者是具有如下性质的二叉树。</p>
<ol>
<li>若它的左子树非空，则左子树上所有结点的值均小于根节点的值。</li>
<li>若它的右子树非空，则右子树上所有结点的值均大于根节点的值。</li>
<li>左、右子树本身就是两棵二叉排序树。</li>
</ol>
<p>一个连通图的生成树是一个极小连通子图，它包含图中的全部顶点，但只有构成一棵树的n-1条边。把生成树各边的权值总和称为生成树的权，把权值最小的生成树称为最小生成树。</p>
<p>平衡二叉树又称为AVL树，它或者是一棵空树，或者是具有下列性质的二叉树。</p>
<ol>
<li>它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</li>
<li>若将二叉树节点的平衡因子（Balance Factor，BF）定义为该结点的左子树的深度减去其右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1，0或1.</li>
<li>只要树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的</li>
</ol>
<p>二叉树的顺序存储，就是用一组连续的存储单元存放二叉树中的结点；把二叉树的所有结点安排成为一个恰当的序列，反映出结点中的逻辑关系；用编号的方法从树根起，自上层至下层，每层从左至右地给所有结点编号。对于这些结点如果没有对应的左右孩子结点，则在对应数组位置存储为空。</p>
<p>二叉树的二叉链表存储结构中每个节点有2个指针。每个节点有0个、1个或者2个空指针对应有2个、1个、0个非空指针。</p>
<h4 id="数据结构与算法基础-gt-其他二叉树"><a href="#数据结构与算法基础-gt-其他二叉树" class="headerlink" title="数据结构与算法基础&gt;其他二叉树"></a>数据结构与算法基础&gt;其他二叉树</h4><p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_%E5%85%B6%E4%BB%96%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
<h4 id="数据结构与算法基础-gt-顺序表与链表"><a href="#数据结构与算法基础-gt-顺序表与链表" class="headerlink" title="数据结构与算法基础&gt;顺序表与链表"></a>数据结构与算法基础&gt;顺序表与链表</h4><p>删除用顺序表存储的元素，最好情况是删除最后一个元素，此时不用移动任何元素，直接删除，最差情况是删除第一个元素，此时需要移动n-1个元素，平均状态是移动（n-1）&#x2F;2。</p>
<p>删除用链表存储的元素，直接将需要删除元素的前趋next指针指向后继元素即可，不需要移动元素，所以移动元素的个数为0。</p>
<p>采用单向循环链表存储的特点之一是从表中任意节点出发都能遍历整个链表，另外便于元素的元素节点的删除与插入。如需要对表中的任意节点进行随机访问需采用顺序存储结构。</p>
<p>顺序存储时，通过元素在存储空间中的相对位置来表示数据元素之间的逻辑关系，元素的逻辑相对位置与物理相对位置是一致的。</p>
<p>链表存储：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p>索引存储：分别存放数据元素和元素间关系的存储方式。</p>
<p>哈希存储：哈希存储的基本思想是以关键字Key为自变量，通过一定的函数关系（散列函数或哈希函数），计算出对应的函数值（哈希地址），以这个值作为数据元素的地址，并将数据元素存入到相应地址的存储单元中。</p>
<h4 id="数据结构与算法基础-gt-最短路径"><a href="#数据结构与算法基础-gt-最短路径" class="headerlink" title="数据结构与算法基础&gt;最短路径"></a>数据结构与算法基础&gt;最短路径</h4><p>贪心算法通过一系列的选择得到问题的解。它所做出的每一次选择都是当前状态下局部最优选择，即贪心选择。</p>
<p>分治法的基本思想是把大问题分解成一些较小的问题，然后又小问题的解方便地构造出大问题的解。</p>
<p>动态规划策略设计算法利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题地最优解。</p>
<p>回溯法也称为试探法，该方法首先暂时放弃关于问题规模大小的限制，并将问题的候选解按某种顺序逐一枚举和检验。</p>
<p>迪杰斯特拉（Dijkstra）提出的按路径长度递增的次序产生最短路径的算法，其思想是把网中所有的顶点分成两个集合S和T，S集合的初态只包含顶点v0，T集合的初态为网中除v0之外的所有顶点。凡以v0为源点，已经确定了最短路径的终点并入S集合中；顶点集合T则是尚未确定最短路径的顶点的集合。按各顶点与v0间最短路径长度递增的次序，逐个把T集合中的顶点加入到S集合中去，使得从v0到S集合中各顶点的路径长度始终不大于从v0到T集合中各顶点的路径长度。其算法属于贪心策略。</p>
<p>求单源点最短路径的迪杰斯特拉（Dijkstra）算法是按路径长度递增的顺序求源点到各顶点的最短路径的。</p>
<h4 id="数据结构与算法基础-gt-散列表（哈希）"><a href="#数据结构与算法基础-gt-散列表（哈希）" class="headerlink" title="数据结构与算法基础&gt;散列表（哈希）"></a>数据结构与算法基础&gt;散列表（哈希）</h4><p>哈希法又称散列法、杂凑法以及关键字计算地址法等，相应的表称为哈希表。其基本思想：首先在元素的关键字K和元素的位置P之间建立一个对应关系f，使得P&#x3D;f(K)，其中f称为哈希函数。创建哈希表时，把关键字K的元素直接存入地址为f(K)的单元；查找关键字K的元素时利用哈希函数计算出该元素的存储位置P&#x3D;f(K)；当关键字集合很大时，关键字值不同的元素可能会映像到哈希表的同一地址上，即K1!&#x3D;K2，但f(K1)&#x3D;f(K2)，这种现象称为hash冲突，实际情况中冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突。</p>
<h4 id="数据结构与算法基础-gt-图的拓扑排序"><a href="#数据结构与算法基础-gt-图的拓扑排序" class="headerlink" title="数据结构与算法基础&gt;图的拓扑排序"></a>数据结构与算法基础&gt;图的拓扑排序</h4><p>对于拓扑排序，需要按照有向弧的指向，明确其先后顺序，例如：存在一条Vi指向Vj的有向弧，那么在拓扑序列中Vi需要写在Vj前面，其次对于属于同一层次或者毫无关联的两个顶点可以不用在意先后顺序。</p>
<h4 id="数据结构与算法基础-gt-排序"><a href="#数据结构与算法基础-gt-排序" class="headerlink" title="数据结构与算法基础&gt;排序"></a>数据结构与算法基础&gt;排序</h4><p>要将两个有序序列归并为一个有序序列时，当一个序列的最大值小于另一个序列的最小值时，这时需要比较的次数最小。当获得新序列后，两个序列的元素交替的情况，这种情况下需比较的次数最多。</p>
<p>直接插入排序是稳定的排序算法，选择排序是不稳定的排序算法</p>
<h4 id="数据结构与算法基础-gt-迭代和递归算法"><a href="#数据结构与算法基础-gt-迭代和递归算法" class="headerlink" title="数据结构与算法基础&gt;迭代和递归算法"></a>数据结构与算法基础&gt;迭代和递归算法</h4><p>递归是设计和描述算法的一种有力的工具</p>
<p>能采用递归描述的算法通常有这样的特征：为求解规模为N的问题，设法将它分解成一些规模较小的问题，然后从这些小问题的解方便地构造出大问题的解，并且这些规模较小的问题能采用同样的分解和综合方法。特别地，当规模N&#x3D;1时，能直接得到解。</p>
<p>由于递归函数执行过程中引起一系列的函数调用和返回，因此需要较多的时间开销（控制转移和存储空间管理操作所需的时间）及空间开销（每一次调用时为函数中的形式参数和自动局部变量分配存储空间等），因此与实现相同功能的非递归函数相比，运行效率较低。</p>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><h4 id="数据库系统-gt-分布式数据库"><a href="#数据库系统-gt-分布式数据库" class="headerlink" title="数据库系统&gt;分布式数据库"></a>数据库系统&gt;分布式数据库</h4><p>分布式数据库是由一组数据组成的，这组数据分布在计算机网络的不同计算机上，网络中的每个节点具有独立处理的能力（称为场地自治），它可以执行局部应用，同时，每个节点也能通过网络通信子系统执行全局应用。分布式数据库系统是在集中式数据库系统技术的基础上发展起来的，具有如下特点：</p>
<ul>
<li>数据独立性。在分布式数据库系统中，数据独立性这一特性更加重要，并具有更多的内容。除了数据的逻辑独立性与物理独立性外，还有数据分布独立性（分布透明性）。</li>
<li>集中与自治共享结合的控制结构。各局部的DBMS可以独立地管理局部数据库，具有自治的功能。同时，系统又设有集中控制机制，协调各局部DBMS的工作，执行全局应用。</li>
<li>适当增加数据冗余度。在不同的场地存储同一数据的多个副本，这样，可以提高系统的可靠性和可用性，同时也能提高系统性能。提高系统的可用性，即当系统中某个节点发生故障时，因为数据有其他副本在非故障场地上，对其他所有场地来说，数据任然是可用的，从而保证数据的完备性。</li>
<li>全局的一致性、可串行性和可恢复性。</li>
</ul>
<p>分片透明：是指用户不必关心数据是如何分片的，它们对数据的操作在全局关系上进行，即关心如何分片对用户是透明的，因此，当分片改变时应用程序可以不变。分片透明性是最高层次的透明性，如果用户能在全局关系一级操作，则数据如何分布，如何存储等细节自不必关心，其应用程序的编写与集中式数据库相同。</p>
<p>复制透明：用户不用关心数据库在网络中各个节点的复制情况，被复制的数据的更新都由系统自动完成。在分布式数据库系统中，可以把一个场地的数据复制到其他场地存放，应用程序可以使用复制到本地的数据在本地完成分布式操作，避免通过网络传输数据，提高了系统的运行和查询效率。但是对于复制数据的更新操作，就要涉及到对所有复制数据的更新。</p>
<p>位置透明：是指用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。</p>
<p>局部映射透明性（逻辑透明）是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关心局部DBMS支持哪种数据模型、使用那种数据操纵语言，数据模型和操纵语言的转换是由系统完成的。因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。</p>
<h4 id="数据库系统-gt-规范化理论基本概念"><a href="#数据库系统-gt-规范化理论基本概念" class="headerlink" title="数据库系统&gt;规范化理论基本概念"></a>数据库系统&gt;规范化理论基本概念</h4><p>All-key关系模型的所有属性组成该关系模式的候选码，称为全码</p>
<h4 id="数据库系统-gt-关系代数"><a href="#数据库系统-gt-关系代数" class="headerlink" title="数据库系统&gt;关系代数"></a>数据库系统&gt;关系代数</h4><p>自然连接的结果以左侧关系为主，右侧关系去除重复列，属性列数为二者之和并减去其中的重复列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E9%A2%98%E7%9B%AE.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0.png"></p>
<p>优化SQL语句，减少比较次数是提高查询效率的有效方法。</p>
<p>投影运算是从一个关系里面抽取指明的属性（列）组成一个新的关系，这种运算是一种对列进行操作的运算。</p>
<h4 id="数据库系统-gt-并发操作"><a href="#数据库系统-gt-并发操作" class="headerlink" title="数据库系统&gt;并发操作"></a>数据库系统&gt;并发操作</h4><p>在事务并行处理的过程中，因为多个事务对相同数据的访问，干扰了其他事务的处理，产生了数据的不一致性，是事务隔离性的破坏导致了一致性的破坏，并发操作带来的数据不一致性有三类：丢失修改、不可重复读和读“脏”数据。</p>
<p>为了保证数据库中数据的安全可靠和正确有效，数据库管理系统（DBMS）提供数据库恢复、并发控制、数据完整性保护与数据安全性保护等功能。数据库在运行过程中由于软硬件故障可能造成数据被破坏，数据库恢复就是在尽可能短的时间内把数据恢复到故障发生前的状态。</p>
<h4 id="数据库系统-gt-数据库三级模式结构"><a href="#数据库系统-gt-数据库三级模式结构" class="headerlink" title="数据库系统&gt;数据库三级模式结构"></a>数据库系统&gt;数据库三级模式结构</h4><p>物理独立性是指的内模式发生变化，只需要调整模式与内模式之间的映像，而不修改应用程序，通过模式与内模式之间的映像来完成。</p>
<p>逻辑独立性是指的模式发生变化，只需要调整外模式与模式之间的映像，而不用修改应用程序，通过外模式与模式之间的映像来完成。</p>
<h4 id="数据库系统-gt-数据库设计过程"><a href="#数据库系统-gt-数据库设计过程" class="headerlink" title="数据库系统&gt;数据库设计过程"></a>数据库系统&gt;数据库设计过程</h4><p>需求分析：分析用户的需求，包括数据、功能和性能需求；得到数据流图、数据字典和需求说明书。</p>
<p>概念设计：用数据模型明确地表示用户的数据需求。其反映了用户的现实工作环境，与数据库的具体实现技术无关（E-R模型）</p>
<p>逻辑设计：根据概念数据模型及软件的数据模型特性，按照一定的转换规则和规范化理论，把概念模型转换为逻辑数据模型，如层次模型、关系模型等。关系规范化是在逻辑设计阶段进行的。</p>
<p>物理设计：为一个确定的逻辑数据模型选择一个最适合应用要求的物理结构的过程。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="操作系统-gt-操作系统的作用"><a href="#操作系统-gt-操作系统的作用" class="headerlink" title="操作系统&gt;操作系统的作用"></a>操作系统&gt;操作系统的作用</h4><p>操作系统作为用户与计算机硬件之间的接口。</p>
<p>操作系统作为计算机系统的资源管理者，可以管理计算机的软硬件资源。</p>
<h4 id="操作系统-gt-页式存储"><a href="#操作系统-gt-页式存储" class="headerlink" title="操作系统&gt;页式存储"></a>操作系统&gt;页式存储</h4><p>在分页存储管理时，将内存划分为大小相等的页面，每一页物理内存叫页帧，以页为单位对内存进行编号，该编号可作为页数组的索引，又称为页帧号。在淘汰页面时，应选择最近没被访问的页面进行淘汰。</p>
<h4 id="操作系统-gt-线程的概念"><a href="#操作系统-gt-线程的概念" class="headerlink" title="操作系统&gt;线程的概念"></a>操作系统&gt;线程的概念</h4><p>在多线程运行环境中，每个线程自己独有资源很少，只有程序计数器、寄存器和栈，其他的资源均是共享进程的</p>
<h4 id="操作系统-gt-位视图"><a href="#操作系统-gt-位视图" class="headerlink" title="操作系统&gt;位视图"></a>操作系统&gt;位视图</h4><p>位视图用每1个bit位表示一个磁盘的使用情况</p>
<h4 id="操作系统-gt-死锁资源数计算"><a href="#操作系统-gt-死锁资源数计算" class="headerlink" title="操作系统&gt;死锁资源数计算"></a>操作系统&gt;死锁资源数计算</h4><p>在有限的资源下，要保证系统不发生死锁，则可以按这种逻辑来分析。首先给每个进程分配所需资源数减1个资源，然后系统还有一个资源，则不可能发生死锁。</p>
<h4 id="操作系统-gt-特殊的操作系统"><a href="#操作系统-gt-特殊的操作系统" class="headerlink" title="操作系统&gt;特殊的操作系统"></a>操作系统&gt;特殊的操作系统</h4><p>实时操作系统是保证在一定时间限制内完成特定功能的操作系统。实时操作系统有硬实时和软实时之分，硬实时要求在规定的时间内必须完成操作，这是在操作系统设计时保证的；软实时则只要按照任务的优先级，尽可能地快完成操作即可。</p>
<h4 id="操作系统-gt-I-x2F-O管理设备"><a href="#操作系统-gt-I-x2F-O管理设备" class="headerlink" title="操作系统&gt;I&#x2F;O管理设备"></a>操作系统&gt;I&#x2F;O管理设备</h4><p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_IO%E7%AE%A1%E7%90%86%E8%AE%BE%E5%A4%87.png"></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h4 id="面向对象-gt-面向对象的基本概念"><a href="#面向对象-gt-面向对象的基本概念" class="headerlink" title="面向对象&gt;面向对象的基本概念"></a>面向对象&gt;面向对象的基本概念</h4><p>静态成员作为类的一种成员，它被类的所有对象共享，而不是属于某个对象的。静态成员分为静态成员变量和静态方法。</p>
<p>静态成员变量的值可以被更新。只要对静态成员变量的值更新一次，所有对象的该静态成员变量的值都会被更新。</p>
<p>静态成员函数可以直接访问静态成员，但不能直接访问非静态成员。</p>
<p>继承：父类和子类之间共享数据的方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p>
<p>消息：对象之间进行通信的一种构造叫做消息。当一个消息发送给某个对象时，包含要求接收对象去执行某些活动的消息。接收到信息的对象经过解释，然后予以响应。这种通信机制叫做消息传递。发送消息的对象不需要知道接收消息的对象如何对请求予以相应。</p>
<p>多态：在收到消息时，对象要予以相应。不同的对象收到同意消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。</p>
<p>覆盖：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override）。</p>
<p>绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才运行。</p>
<p>动态绑定是和类的继承以及多态相关联的。在继承关系中，子类是父类的一个特例，所以，父类对象可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送信息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定。</p>
<p>泛化概化关系表示把几类对象类的公共属性和行为抽象成超类，然后其属性和方法被那些子类继承；</p>
<p>聚合关系表示一个较大的”整体”类包含一个或多个较小的”部分”类；</p>
<p>合成关系则表示关系中”整体”负责其”部分”的创建和销毁，如果”整体”不存在了，”部分”也将不存在。</p>
<p>实体类主要负责数据和业务逻辑；边界类负责和用户进行交互，即用户界面；控制类则负责实体类和边界类的交互。</p>
<p>参数多态：应用广泛、最纯的多态。</p>
<p>包含多态：同样的操作可用于一个类型及其子类型，包含多态一般需要进行运行时的类型检查。包含多态在许多语言中都存在，最常见的例子就是子类型化，即一个类型是另外一个类型的子类型。</p>
<p>强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。</p>
<p>过载多态：同一个名（操作符、函数名）在不同的上下文中有不同的类型。</p>
<h4 id="面向对象-gt-面向对象设计原则"><a href="#面向对象-gt-面向对象设计原则" class="headerlink" title="面向对象&gt;面向对象设计原则"></a>面向对象&gt;面向对象设计原则</h4><p>接口分离原则：使用多个专门的接口要比使用单一的总接口要好。</p>
<p>开放-封闭原则：对扩展开放，对修改关闭。</p>
<p>里氏替换原则：子类可以替换父类</p>
<p>单一职责原则：设计目的单一的类</p>
<p>共同封闭原则：包中的所有类对于同一性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包里的所有类产生影响，而对于其他的包不造成任何影响。</p>
<p>共同重用原则：一个包里的所有类应该是共同重用的。如果重用了包里的一个类，那么就要重用包中的所有类。</p>
<p>面向对象设计中存在很多原则，其中高层模块不应该依赖于底层模块就是其中一条。传统的结构化设计中，一般的高层模块需要调用或使用底层模块，导致高层模块必须依赖于底层模块，但借助面向对象中的抽象类、接口等一系列机制，可以使得高层模块仅仅与接口耦合，而和实际的底层模块没有直接关联。</p>
<h4 id="面向对象-gt-设计模式的图"><a href="#面向对象-gt-设计模式的图" class="headerlink" title="面向对象&gt;设计模式的图"></a>面向对象&gt;设计模式的图</h4><p>桥接模式（Bridge）的作用在于将接口与其实现分离，使得接口和实现的变化不产生相互影响。（将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化。）</p>
<p>桥接模式是结构型对象模式。</p>
<p>外观模式（Facade）是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统提供一个统一的入口，降低子系统和客户端的耦合度，且客户端调用非常方便。</p>
<p>适配器模式（Adapter）：将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作。</p>
<p>责任链模式（Chain of Responsibility）：通过给多个对象处理请求的机会，减少请求的发送者和接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。</p>
<p>单件（Singleton）设计模式保证一个类仅有一个对象。</p>
<p>装饰（Decorator）可以动态地给一个对象添加一些额外的职责。</p>
<p>有State关键词为状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的（stateful）对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p>
<p>状态模式是一种行为型对象模式。</p>
<p>观察者（Observer）模式的意图是：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>设计模式是对被用来在特定场景下解决一般设计问题的类和互相通信的对象的描述。一般而言一个设计模式有4个基本要素：模式名称、问题（模式的使用场合）、解决方案和效果。</p>
<p>每一个设计模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。设计模式使人们可以更加简单方便地复用成功地设计和体系结构；将已证实的技术表述成设计模式，也会使新系统的开发者更加容易理解其设计思路。设计模式可以帮助开发者做出有利于复用的选择，避免设计时损害系统复用性。</p>
<h4 id="面向对象-gt-设计模式的分类"><a href="#面向对象-gt-设计模式的分类" class="headerlink" title="面向对象&gt;设计模式的分类"></a>面向对象&gt;设计模式的分类</h4><p>常见的创建型模式主要有抽象工厂（Abstract Factory）、构建器（Builder）、工厂方法（Factory Method）、原型（Prototype）模式、单例（Singleton）；</p>
<p>结构型模式有适配器（Adapter）、桥接（Bridge）模式、组合（Composite）、装饰（Decorator）、外观（Facade）、享元（Flyweight）、代理（Proxy）；</p>
<p>行为型模式有责任链（Chain of Responsibility）、命令（Command）、解释器（Interpreter）、迭代器（Iterator）、中介者（Mediator）、备忘录（Memento）、观察者（Observer）模式、状态（State）、策略（Strategy）、模板方法（Template Method）、访问者（Visitor）。</p>
<h4 id="面向对象-gt-设计模式的应用场景"><a href="#面向对象-gt-设计模式的应用场景" class="headerlink" title="面向对象&gt;设计模式的应用场景"></a>面向对象&gt;设计模式的应用场景</h4><p>单例模式的最大特点是一个类只有一个实例</p>
<p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<p>应用场景：</p>
<ol>
<li>多个类之区别在表现型为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</li>
<li>需要在不同情况下使用不同的策略（算法），或者策略还可能在未来用其他方式来实现。</li>
<li>对客户隐藏具体策略（算法）的实现细节，彼此完全独立。</li>
</ol>
<p><strong>创建型模式</strong></p>
<p>抽象工厂模式（Abstract Factory）：提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类。</p>
<p>构建器模式（Builder）：将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示。</p>
<p>工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程延迟。</p>
<p>原型模式（Prototype）：用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象。</p>
<p>单例模式（Singleton）：保证一个类只有一个实例，并且通过拷贝这个原型来创建新的对象。</p>
<p><strong>结构型模式</strong></p>
<p>适配器模式（Adapter）：将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作。</p>
<p>桥接模式（Bridge）：将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化。</p>
<p>组合模式（Composite）：将对象组合成树形结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>装饰模式（Decorator）：动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活。</p>
<p>外观模式（Facade）：定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用。</p>
<p>享元模式（Flyweight）：提供支持大量细粒度对象对象共享的有效方法。</p>
<p>代理模式（Proxy）：为其他对象提供一种代理以控制这个对象的访问。</p>
<p><strong>行为型模式</strong></p>
<p>职责链模式（Chain of Responsibility）：通过给多个对象提供处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。</p>
<p>命令模式（Command）：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。</p>
<p>解释器模式（Interpreter）：给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子。</p>
<p>迭代器模式（Iterator)：用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互。</p>
<p>备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。</p>
<p>观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p>
<p>状态模式（State）：允许一个对象在其内部状态改变时改变它的行为。</p>
<p>策略模式（Strategy）：定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替代，从而让算法可以独立于使用它的用户而变化。</p>
<p>模板方法模式（Template Method）：定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤。</p>
<p>访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<h4 id="面向对象-gt-软件开发过程"><a href="#面向对象-gt-软件开发过程" class="headerlink" title="面向对象&gt;软件开发过程"></a>面向对象&gt;软件开发过程</h4><p>面向对象的软件开发过程包括分析、系统设计、开发类、组装测试和应用维护等。其中分析过程包括问题域分析、应用分析，此阶段主要识别对象及对象之间的关系，最终形成软件的分析模型，并进行评估。设计阶段主要构造软件总的模型，实现相应源代码，在此阶段，需要发现对象的过程，确定接口规格</p>
<h4 id="面向对象-gt-UML图的定义"><a href="#面向对象-gt-UML图的定义" class="headerlink" title="面向对象&gt;UML图的定义"></a>面向对象&gt;UML图的定义</h4><p>状态图展现了一个状态机，它由状态、转换、事件和活动组成，通常包括简单状态和组合状态、转换（事件和动作）。</p>
<p>由于状态可以是单一的，也可以是嵌套的（嵌套在另一个状态中的状态称为子状态，含有子状态的状态称为组合状态，所以活动可以在状态内进行，也可以在状态迁移时执行。</p>
<p>转换（迁移）是两个状态之间的一种关系，表示对象将在源状态执行一定的事件或动作，并在某个特定事件发生而且某个特定的监护条件满足时离开当前状态而进入目标状态，事件触发没有特定监护条件的迁移，对象也会离开当前状态。</p>
<p>转换（迁移）是从源状态和目的状态之间的一种关系，可以包含触发事件、监护条件、状态（源状态和目的状态）、动作。</p>
<p>当某个事件发生后，对象的状态将发生变化事件可以触发迁移。</p>
<p>部署图展现了运行处理节点以及其中的构件的配置。部署图给出了体系结构的静态实施视图。它与构件视图相关，通常一个结点包含一个或多个构件。部署图一般描述的是代码或系统在实施的物理节点分布，组件之间的依赖关系类似于包依赖。</p>
<p>构件应该是物理模块而不是逻辑模块。</p>
<h4 id="面向对象-gt-UML图的分类"><a href="#面向对象-gt-UML图的分类" class="headerlink" title="面向对象&gt;UML图的分类"></a>面向对象&gt;UML图的分类</h4><p>事务：模型中的基本成员。UML中包括结构事物、行为事物、分组事物和注释事物。</p>
<ol>
<li>结构事物：模型中的静态部分。【类Class】+【接口Interface】+【协作Collaboration】+【用例Use Case】+【活动类】+【组件Component】+【结点Node】</li>
<li>行为事物：模型中的动态部分。【交互】+【状态机】</li>
<li>分组事物：可以把分组事物看成是一个”盒子”，模型可以在其中被分解。目前只有一种分组事物，即包（package）。结构事物、动作事物甚至分组事物都有可能放在一个包中。包存粹是概念上的，只存在于开发阶段，而组件在运行时存在。</li>
<li>注释事物：注释事物是UML模型的解释部分。</li>
</ol>
<h4 id="面向对象-gt-UML图的图示；"><a href="#面向对象-gt-UML图的图示；" class="headerlink" title="面向对象&gt;UML图的图示；"></a>面向对象&gt;UML图的图示；</h4><p>通信图（communication diagram）是一种交互图，它强调收发消息的对象或参与者的结构组织。顺序图和通信图表达了类似的基本概念，但它们所强调的概念不同，顺序图强调的是时序，通信图强调的是对象之间的组织结构（关系）。</p>
<ul>
<li>类图（class diagram）：展示了一组对象、接口、协作和它们之间的关系，在面向对象系统的建模中所建立的最常见的图就是类图。类图给出系统的静态设计视图，包含主动类的类图给出了系统的静态进程视图。</li>
<li>对象图（object diagram）：展现了一组对象以及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照。和类图相同，这些图给出系统的静态设计图或动态进程视图，但它们是从真实的或原型案例的角度建立的。</li>
<li>用例图（use case diagram）：展现了一组用例、参与者（actor）以及它们之间的关系。用例图给出系统的静态用例视图。这些图对系统的行为进行组织和建模是非常重要的。</li>
<li>序列图（sequence diagram）：是场景（scenario）的图形化表示。描述了以时间顺序组织的对象之间的交互活动。</li>
<li>协作图（collaboration或 communication diagram）：强调收发消息的对象的结构组织。</li>
</ul>
<p>序列图和协作图都是交互图（interaction1 diagram）。交互图展现了一种交互它由一组对象和它们之间的关系组成，包括它们之间可能发送的消息。交互图关注系统的动态试图。序列图和协作图是同构的，它们之间可以相互转换。</p>
<ul>
<li><p>状态图（state chart diagram）：展现了一个状态机，它由状态、转换、事件和活动组成。状态图关注系统的动态试图，它对于接口、类和协作的行为建模尤为重要，它强调对象行为的时间顺序。</p>
</li>
<li><p>活动图（activity diagram）：是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。活动图专注于系统的动态试图。它对于系统的功能建模特别重要，并强调对象间的控制流程。</p>
</li>
<li><p>构件图（component diagram）：展现了一组构件之间的组织和依赖。构件图专注于系统的静态实现视图。它与类图相关，通常把构建映射成一个或多个类、接口或协作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_UML%E5%9B%BE%E7%9A%84%E5%9B%BE%E7%A4%BA.png"></p>
</li>
<li><p>部署图（deployment diagram）：展现了运行处理结点以及其中的构建的配置。部署图给出了体系结构的静态实施图。它与构件图相关，通常一个节点包含一个或多个构件。</p>
</li>
</ul>
<p>部署图用于展示所交付系统中软件组织和硬件之间的物理关系。</p>
<p>用例视图从外部参与者的角度描述系统功能；</p>
<p>逻辑视图从系统的静态结构和动态行为角度显示系统内部如何实现系统功能</p>
<p>实现视图反映源代码结构和实际的执行代码。</p>
<p>如果一个对象发送了一个同步消息，那么它要等待对方对消息的应答，收到应答后才能继续自己的操作。而发送异步消息的对象不需要等待对方对消息的应答便可以继续自己的操作。</p>
<h4 id="面向对象-gt-UML图中的关系"><a href="#面向对象-gt-UML图中的关系" class="headerlink" title="面向对象&gt;UML图中的关系"></a>面向对象&gt;UML图中的关系</h4><p>依赖关系：一件事物发生改变影响到另一个事物。</p>
<p>关联关系：描述了一组链，链是对象之间的连接。</p>
<p>聚合关系：整体与部分生命周期不同的关系。</p>
<p>组合关系：整体与部分生命周期相同的关系。</p>
<p>在类与类之间的五种关系中，从弱到强依次为：依赖、关联、聚合、组合和继承。</p>
<p>粗实线表示并发，并发分为并发分支和并发汇合。</p>
<h4 id="面向对象-gt-面向对象开发各阶段划分及任务"><a href="#面向对象-gt-面向对象开发各阶段划分及任务" class="headerlink" title="面向对象&gt;面向对象开发各阶段划分及任务"></a>面向对象&gt;面向对象开发各阶段划分及任务</h4><p>面向对象分析与设计是面向对象软件开发过程中的两个重要阶段，面向对象分析产生分析模型，该分析模型可以使用UML表达，面向对象设计以分析模型为基础。继续对分析模型进行精华，得到设计模型，其表达仍然可以采用UML建模语言。</p>
<p>面向对象分析主要强调理解问题是什么，不考虑问题的解决方案。</p>
<p>面向对象设计侧重问题的解决方案，并且需要考虑实现细节问题。</p>
<p>面向对象分析阶段：认定对象、组织对象、对象间的相互作用，基于对象的操作。</p>
<p>面向对象设计阶段：识别类及对象、定义属性、定义服务、识别关系、识别包。</p>
<p>面向对象程序设计：程序设计范型、选择一种OOPL。</p>
<p>面向对象测试：算法层、类层、模板层、系统层。</p>
<h4 id="面向对象-gt-其它"><a href="#面向对象-gt-其它" class="headerlink" title="面向对象&gt;其它"></a>面向对象&gt;其它</h4><p>现有的面向对象语言有很多已经不再提供全局变量和全局函数的定义，实践也证明了全局变量和函数并不是一种很好的程序设计风格，因此该特点不应该作为语言选择需要考虑的因素之一。</p>
<p>经典的MVC模式中，边界对象表示了系统与参与者之间的接口，该对象从参与者处收集信息，并将之转换为两种被实体对象和控制对象使用的形式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_UML%E5%9B%BE%E5%BD%A2%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA.png"></p>
<h2 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h2><h4 id="程序设计语言-gt-有限自动机"><a href="#程序设计语言-gt-有限自动机" class="headerlink" title="程序设计语言&gt;有限自动机"></a>程序设计语言&gt;有限自动机</h4><p>有限自动机是进行词法分析的工具。</p>
<p>非确定有限状态自动机与确定有限状态自动机的最大区别是它们的转移函数不同。确定有限状态自动机对每一个可能的输入只有一个状态的转移。非确定有限状态自动机对每一个可能的输入可以有多个状态转移，接收到输入时从这多个状态转移中非确定地选择一个。</p>
<h4 id="程序与语言设计-gt-编译器工作过程"><a href="#程序与语言设计-gt-编译器工作过程" class="headerlink" title="程序与语言设计&gt;编译器工作过程"></a>程序与语言设计&gt;编译器工作过程</h4><p>编译与解释的区别在于：</p>
<ul>
<li><p>编译直接生成目标代码，在机器上执行而编译器不需要参与执行，因此程序执行速度快。</p>
</li>
<li><p>解释则生成中间代码或其等价形式，程序执行时需要解释器的参与，并且由解释器控制程序的执行，因此执行速度慢。</p>
</li>
</ul>
<p>目标代码生成阶段应考虑直接影响到目标代码速度的三个问题：一是如何生成较短的目标代码；二是如何充分利用计算机中的寄存器，减少目标代码访问存储单元的次数；三是如何充分利用计算机指令系统的特点，以提高目标代码的质量。</p>
<p>编译程序的功能是从源代码（通常为高级语言）到能直接被计算机或虚拟机执行的目标代码（汇编语言或机器语言）的翻译过程。工作过程分为6个阶段：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成。</p>
<p>各个阶段逻辑上可以分为前端和后端。前端主要负责解析输入的源代码，由语法分析器和语意分析器协同工作。语法分析器负责把源代码中的’单词’找出来，语义分析器把这些分散的单词按预先定义好的语法组装成有意义的表达式、语句、函数等等。前端还负责语义的检查，例如检测参与运算的变量是否是同一类型的，简单的错误处理。最终的结果常常是一个抽象的语法树，这样后端可以在此基础上进一步优化处理。</p>
<p>后端编译器后端主要负责分析、优化中间代码以及生成机器代码。</p>
<p>对于声明语句，需要记录符号信息。</p>
<p>对于可执行语句，需要翻译成中间代码或目标代码。</p>
<p>符号表：符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。</p>
<p>翻译的任务：首先是语义分析和正确性检查，若正确，则翻译成中间代码或目标代码。其基本思想是，根据翻译的需要设置文法符号的属性，以描述语法结构的语义。例如，一个变量的属性有类型，层次，存储地址等。表达式的属性有类型、值等。属性值的计算和产生式相联系，随着语法分析的进行，执行属性值的计算，完成语义分析和翻译的任务。</p>
<p>语法指导翻译是一种静态语义分析方法。</p>
<p>数据具有类型，便于编译程序在基础机器中完成对值的布局，同时还可用于检查表达式中对运算的应用是否正确。</p>
<p>词法分析：从左到右逐个扫描源程序中的字符，识别其中如关键字（或称保留字）、标识符、常数、运算符以及分隔符（标点符号和括号）等。</p>
<p>语法分析：根据语法规则将单词符号分解成各类语法单位，并分析源程序是否存在语法上的错误。包括：语言结构出错、if…end if不匹配，缺少分号、括号不匹配、表达式缺少操作数等。</p>
<p>语义分析：进行类型分析和检查，主要检测程序是否存在静态语义错误。包括：运算符和运算类型不符合，如取余时用浮点数。</p>
<p>语义分析阶段主要是分析各语法结构的含义，检查源程序是否包含静态语义错误，并收集类型信息提供后面的代码生成阶段使用。</p>
<p>在确认源程序的语法和语义后，可以对其进行翻译并给出源程序的内部表示。对于声明语句，需要记录所遇到的符号的信息，所以应该进行符号表的填查工作，用来记录源程序中各个符号的必要信息，以辅助语义的正确性检查和代码生成。</p>
<p>决策表是用于测试的，广义表是针对数据结构的表示，索引表是数据库中指示逻辑和物理记录对应的关系。</p>
<h4 id="程序设计语言-gt-程序语言基本知识"><a href="#程序设计语言-gt-程序语言基本知识" class="headerlink" title="程序设计语言&gt;程序语言基本知识"></a>程序设计语言&gt;程序语言基本知识</h4><p>函数式程序设计的数据结构本质上是表，而函数又可以作为值出现在表中，因此函数式程序的控制结构取决于函数，以及函数的定义和调用。函数式语言主要用于符号数据处理，如微分和积分演算、数理逻辑、游戏推演以及人工智能等其他领域。</p>
<p>用逻辑式程序设计语言编写程序不需要描述具体的解题过程，只需要给出一些必要的事实和规则。这些规则是解决问题的方法的规范说明，根据这些事实和规则，计算机利用谓词逻辑，通过演绎推理得到求解问题的执行序列。这种语言主要用在人工智能领域，也应用在自然语言处理、数据库查询、算法描述等方面，尤其适合于作为专家系统的开发工具。</p>
<p>逻辑式语言是一类以形式逻辑为基础的语言。</p>
<p>函数语言以λ-演算为其语义基础。</p>
<p>命令式语言是基于动作的语言，在这种语言中，计算被看成是动作的序列。通过指明一系列可执行的运算及运算的次序来描述计算过程是命令式语言的特点。</p>
<h4 id="程序设计语言-gt-编译与解释"><a href="#程序设计语言-gt-编译与解释" class="headerlink" title="程序设计语言&gt;编译与解释"></a>程序设计语言&gt;编译与解释</h4><p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80_%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A.png"></p>
<p>编译程序的功能就是把高级语言书写的源程序翻译成与之等价的目标程序（汇编语言或机器语言）。</p>
<p>解释程序是另一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同，但在运行时直接执行源程序或源程序的内部形式，即解释程序不产生源程序的目标程序，这点是它与编译程序的主要区别</p>
<p>用高级语言编写的程序不能直接被机器执行，而是经过相关的处理后，将其变成目标程序后才能被机器执行，而这一过程就是一个编译的过程，而实现这个功能的程序就称为编译程序。</p>
<p>编译程序对高级语言源程序进行翻译时，在逻辑地址空间中为变量分配存储单元，当程序开始运行时，再转换为实际的内存地址（即物理地址）。</p>
<h4 id="程序设计语言-gt-错误管理"><a href="#程序设计语言-gt-错误管理" class="headerlink" title="程序设计语言&gt;错误管理"></a>程序设计语言&gt;错误管理</h4><p>在C程序中，若在某个表达式中引用了未赋初值的变量，那么程序是可以通过编译并运行的，因为程序中并没有语法方面的错误，只是运行的结果可能与我们期望的结果不一致。</p>
<h4 id="程序设计语言-gt-多种程序语言特点"><a href="#程序设计语言-gt-多种程序语言特点" class="headerlink" title="程序设计语言&gt;多种程序语言特点"></a>程序设计语言&gt;多种程序语言特点</h4><p>C++：是在C语言的基础上发展起来的，主要增加了类的功能，使其成为面向对象的程序实际语言。</p>
<p>Prolog：是以特殊的逻辑推理形式回答用户的查询，它建立在关系理论和一阶谓词理论基础上。经常用于数据库和专家系统。</p>
<p>Python：是一种面向对象、解释性计算机程序设计语言。Python语法简洁而清晰，具有丰富和强大的类库。因其能够把用其他语言制作的各种模块（尤其是C&#x2F;C++）很轻松地联结在一起，常被昵称为胶水语言。</p>
<p>C语言：编译型语言。</p>
<p>变量是内存单元的抽象，用于在程序中表示数据。当变量存储的是内存单元地址时，成为指针变量，或者说指针变量指向了另一个变量。指针变量可以定义在函数或复合语句内，无论指针变量指向何种变量，其存储空间大小都是一样的。当指针变量指向数组中的一个元素时，对指针变量进行算术运算可以使其指向同一数组中的其它元素。</p>
<h4 id="程序设计语言-gt-文法"><a href="#程序设计语言-gt-文法" class="headerlink" title="程序设计语言&gt;文法"></a>程序设计语言&gt;文法</h4><p>上下文无关文法：形式语言理论中一种重要的变换文法，用来描述上下文无关语言，在乔姆斯基分层中称为2型文法。</p>
<p>上下文无关文法重要的原因在于它们拥有足够强的表达力来表示大多数程序设计语言的语法；实际上，几乎所有程序设计语言都是通过上下文无关文法来定义的。另一方面，上下文无关文法又足够简单，使得我们可以构造有效的分析算法来检验一个给定字串是否是由某个上下文无关文法产生的。</p>
<h4 id="程序设计语言-gt-中间代码"><a href="#程序设计语言-gt-中间代码" class="headerlink" title="程序设计语言&gt;中间代码"></a>程序设计语言&gt;中间代码</h4><p>中间代码的表达形式有语法树、后缀式和三地址代码。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="计算机网络-gt-其他"><a href="#计算机网络-gt-其他" class="headerlink" title="计算机网络&gt;其他"></a>计算机网络&gt;其他</h4><p>帧中继是在X.25协议的基础上发展起来的面向可变长度帧的数据传输技术，它减少X.25的一些流量和差错控制过程，相对X.25来说，通信开销少，传输速度更快。</p>
<p>DDN是数字数据网的简称，是一种我们平时所说的专线上网方式，它将数万、数十万条以光缆为主体的数字电路，通过数字电路管理设备，构成一个传输速率高、质量好，网络延时小、全透明、高流量的数据传输基础网络。帧中继提供面向连接的虚电路服务，因此比DDN专线更能提高通信线路利用率，用户负担的通信费用也更低廉。</p>
<p>相对DDN来说，帧中继具有更灵活的方式来支持突发式通信。</p>
<p>异步传输模式比帧中继能提供更高的数据速率。</p>
<h4 id="计算机网络-gt-协议应用提升"><a href="#计算机网络-gt-协议应用提升" class="headerlink" title="计算机网络&gt;协议应用提升"></a>计算机网络&gt;协议应用提升</h4><p>Administrator组成员就是系统管理员，即所谓的超级用户，是电脑里权限不受限制的人。</p>
<p>Guests这个账户没有修改系统设置和进行安装程序的权限，也没有创建和修改任何文档的权限，只能是读取计算机系统信息和文件。</p>
<p>User则是让普通用户使用的账户。它的级别和权限介于”Administrator“和”Guests“之间的，即是这个账户没有修改系统设置和进行安装程序的权限，但拥有创建修改任何文档的权限。</p>
<h4 id="计算机网络-gt-子网划分与路由汇聚"><a href="#计算机网络-gt-子网划分与路由汇聚" class="headerlink" title="计算机网络&gt;子网划分与路由汇聚"></a>计算机网络&gt;子网划分与路由汇聚</h4><p>变长子网的可用主机数计算公式为2^n-2（n为表示主机的位数）。</p>
<h4 id="计算机网络-gt-常用命令"><a href="#计算机网络-gt-常用命令" class="headerlink" title="计算机网络&gt;常用命令"></a>计算机网络&gt;常用命令</h4><p>ipconfig 显示简要信息，不能查看DHCP服务开启情况。</p>
<p>ipconfig &#x2F;all 显示详细信息，可查看DHCP服务是否已启用。</p>
<p>ipconfig &#x2F;renew 更新所有适配器的DHCP配置，该命令仅在具有配置为自动获取IP地址的适配器的计算机上可用。</p>
<p>ipconfig &#x2F;release 释放所有匹配的连接</p>
<p>inconfig&#x2F;flushdns 刷新并重设DNS解析器缓存</p>
<p>netstat -r 用于显示核心路由表</p>
<p>arp -a 用于查看ARP高速缓存中的内容</p>
<p>netstat是控制台命令，是一个监控TCP&#x2F;IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</p>
<p>nslookup是一个监测网络中DNS服务器是否能正确实现域名解析的命令行工具。</p>
<p>ping命令常用于测试连通性，在此过程中可看出是直接ping的目标地址。</p>
<p>tracert是路由跟踪实用程序，用于确定IP数据包访问目标所采取的路径。</p>
<p>nslookup、ping、tracert都可以加上一个主机域名作为其命令参数来诊断DNS故障，nslookup还可以看到本地DNS服务器地址。netstat命令一般用于检验本机各端口的网络连接情况，与DNS无关联。</p>
<h4 id="计算机网络-gt-HTML语言"><a href="#计算机网络-gt-HTML语言" class="headerlink" title="计算机网络&gt;HTML语言"></a>计算机网络&gt;HTML语言</h4><p>alink用于设置正在被击中的链接的颜色。Vlink用于设置已使用的链接的颜色。background用于设置背景图片的URL。bgcolor用于设置文档整体颜色背景。</p>
<p>&lt; tr&gt;标记用于定义表格中的一行，&lt; col&gt;标记用于定义表格中的一个或多个列的属性值，&lt; td&gt;标记用于定义表格中的一个单元格，&lt; title&gt;标记用于定义文档标题。</p>
<h4 id="计算机网络-gt-路由配置"><a href="#计算机网络-gt-路由配置" class="headerlink" title="计算机网络&gt;路由配置"></a>计算机网络&gt;路由配置</h4><p>对于多种不同的路由协议到一个目的地的路由信息，路由器首先根据管理距离决定相信哪一个协议。</p>
<p>动态路由选择算法就是自适应路由选择算法，依靠当前网络的状态信息进行决策，从而使路由选择结果在一定程度上适应网络拓扑结构和通信量的变化，需要根据网络信息经常更新路由。</p>
<h4 id="计算机网络-gt-TCP与UDP"><a href="#计算机网络-gt-TCP与UDP" class="headerlink" title="计算机网络&gt;TCP与UDP"></a>计算机网络&gt;TCP与UDP</h4><p>在TCP的实现机制中，为了保障传输的可靠性，所以发送方每发送一个报文，接收方接到之后会回发确认信息。如果发送端的数据过多或者数据发送效率过快，致使接收端来不及处理，则会造成数据在接收端的丢弃。为了避免这种现象的发生，通常的处理办法是采用流量控制，即控制发送端发送的数据量及数据发送速率。</p>
<p>流量控制的目的是在接收端有限承受能力的情况下，通过流量约束，减少接收端处的数据丢失，提高数据发送效率，充分利用接收端资源。</p>
<p>可变滑动窗口流量控制的基本过程如下：</p>
<ol>
<li>在建立TCP连接阶段，双方协商窗口尺寸，同时接收端预留数据缓冲区；</li>
<li>发送端根据协商的结果，发送符合窗口尺寸的数据字节流，并等待对方的确认；</li>
<li>发送端根据确认信息，改变窗口的尺寸。</li>
</ol>
<p>注：窗口也就是缓冲区，发送方窗口大小决定了一次可以连续发送多少个数据。</p>
<h4 id="计算机网络-gt-常见TCP-x2F-IP协议基础"><a href="#计算机网络-gt-常见TCP-x2F-IP协议基础" class="headerlink" title="计算机网络&gt;常见TCP&#x2F;IP协议基础"></a>计算机网络&gt;常见TCP&#x2F;IP协议基础</h4><p>POP3（Post Office Protocol 3）协议采用的是C&#x2F;S结构，同时该协议基于传输层TCP协议，所以客户端软件与POP3服务器会建立可靠的连接—TCP连接。</p>
<p>POP3邮件收取协议。</p>
<p>SMTP邮件传输协议。</p>
<p>IMAP4协议与POP3协议一样也是规定个人计算机如何访问网上的邮件的服务器进行收发邮件的协议，但是IMAP4协议同POP3协议相比更高级。</p>
<p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</p>
<p>25端口号为SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）服务器开放，主要用于发送邮件。</p>
<p>110端口为POP3（Post Office Protocol - Version 3，邮件协议版本3）负责邮件收取。</p>
<p>WEB服务主要是HTTP协议，端口为80.</p>
<p>DNS服务主要是DNS协议，端口为53。</p>
<p>ARP和ICMP是网络层协议，X.25是标准的接口协议。</p>
<p>SNMP是应用层协议，SNMP协议的报文是封装在UDP协议中传送。</p>
<p>FTP协议占用两个标准的端口号：20和21，其中20为数据口，21为控制口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/limitlau/blog_pictures@main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E5%B8%B8%E8%A7%81TCP_IP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80.png"></p>
<h4 id="计算机网络-gt-URL"><a href="#计算机网络-gt-URL" class="headerlink" title="计算机网络&gt;URL"></a>计算机网络&gt;URL</h4><p>标准的URL格式如下：</p>
<p>协议：&#x2F;&#x2F;主机名.域名.域名后缀或IP地址（：端口号）&#x2F;目录&#x2F;文件名。</p>
<p>域名地址用来在Internet上确定唯一位置的地址，通常用来指明所使用的计算机资源位置及查询信息的类型。其由字母或数字组成，中间以”.”隔开。</p>
<h4 id="计算机网络-gt-路由配置-1"><a href="#计算机网络-gt-路由配置-1" class="headerlink" title="计算机网络&gt;路由配置"></a>计算机网络&gt;路由配置</h4><p>RIP：RIP（Routing Information Protocol，路由信息协议）是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。</p>
<p>OSPF：OSPF（Open Shortest Path First，开放式最短路径优先）是一种内部网关协议（Interior Gateway Protocol，简称IGP），用于在单一自治系统（Autonomous System，AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作与自治系统内部。</p>
<p>BGP：边界网关协议是运行于TCP上的一种自治系统的外部网关协议。BGP是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议。</p>
<p>UDP：传输层协议。</p>
<h4 id="计算机网络-gt-网络接入技术"><a href="#计算机网络-gt-网络接入技术" class="headerlink" title="计算机网络&gt;网络接入技术"></a>计算机网络&gt;网络接入技术</h4><p>在无线通信技术中，蓝牙的传输距离最短，一般为10m左右，用于连接本地的外围设备，例如打印机、鼠标等。</p>
<h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><h4 id="项目管理-gt-风险管理"><a href="#项目管理-gt-风险管理" class="headerlink" title="项目管理&gt;风险管理"></a>项目管理&gt;风险管理</h4><p>软件开发中的风险与高级管理人员的支持程度有关，与对系统需求理解的程度有关，与开发资金的及时投入有关，但是与最终用户无关，系统的最后部署与运行不属于开发过程。Boehm提出的十大风险是：开发人员短缺、不能实现的进度和预算、开发了错误的软件功能、开发了错误的用户接口、华而不实的需求、需求不断地变动、外部执行的任务不符合要求、外部提供的组件不符合要求、实时性不符合要求、超出了计算机科学发展的水平。</p>
<p>在进行风险管理时，风险控制的目的是辅助项目组建立处理风险的策略，有效的策略应考虑风险避免、风险监控、风险管理及意外事件计划，</p>
<p>软件风险一般包括不确定性和损失两个特性，其中不确定性是指风险可能发生，也可能不发生；损失是当风险确实发生时，会引起的不希望的后果和损失。</p>
<p>救火和危机管理是对不适合但经常采用的软件风险管理策略。</p>
<p>已知风险和未知风险是对软件风险进行分类的一种方式。</p>
<p>员工和预算是在识别项目风险时需要识别的因素。</p>
<h4 id="项目管理-gt-Gant图与Pert图"><a href="#项目管理-gt-Gant图与Pert图" class="headerlink" title="项目管理&gt;Gant图与Pert图"></a>项目管理&gt;Gant图与Pert图</h4><p>关键路径是从起点到终点长度最长的那条路径，而关键路径的长度则是整个项目的工期。</p>
<p>要求活动的松弛时间，就要求出活动的最早开始时间和最晚开始时间，其最晚开始时间减去最早开始时间，就是活动的松弛时间。</p>
<p>甘特图、PERT（计划评审技术）图及CPM（关键路径法）图是软件项目管理中常用的管理开发进度的工具，鱼骨图是常用来发现问题根源并提出解决问题的有效办法的工具。在这三种开发进度管理工具图中，甘特图能够消息描述每个任务的开始&#x2F;结束时间及各任务之间的并行性，也可以动态地反映项目的开发进展情况，，但难以反映多个任务之间存在的逻辑关系；PERT利用项目的网络图和各活动所需时间的估计值（通过加权平均得到的）去计算项目总时间，强调任务之间的先后关系，但不能反映任务之间的并行性，以及项目的当前进展情况；CPM借助网络图和各活动所需时间，计算每一活动的最早或最迟开始和结束时间。CPM的关键是计算总时差，这样可决定哪一活动有最小时间弹性。PERT利用项目的网络图和各活动所需时间的估计值（通过加权平均得到）去计算项目总时间。PERT不同于CPM的主要点在于PERT利用期望值而不是最可能的活动所需时间估计（在CPM法中用的）。</p>
<p>软件项目计划的一个重要内容是安排进度，常用的方法有Gant图和PERT图。Gant图用水平条状图描述，它以日历为基准描述项目任务，可以清楚地表示任务的持续时间和任务之间的并行，打不是不能清晰地描述各个任务之间的依赖关系。PERT图是一种网络模型，描述一个项目任务之间的关系。可以明确表达任务之间的依赖关系，即哪些任务完成后才能开始另一些任务，以及如期完成整个工程的关键路径。PERT图不能清晰地描述各任务之间的并行情况。</p>
<h4 id="项目管理-gt-成本管理"><a href="#项目管理-gt-成本管理" class="headerlink" title="项目管理&gt;成本管理"></a>项目管理&gt;成本管理</h4><p>在模型层次结构中有3种不同规模估算选择，即：功能点、对象点和代码行。</p>
<p>软件成本估算比较常用的模型有Putnam模型，功能点模型，COCOMO模型和后续的COCOMO II模型。其中以COCOMO II模型的使用最为广泛，它是COCOMO模型的改进，以成本为主要因素，考虑多成本驱动因素。COCOMO II 包括三个阶段性模型，即应用组装模型、早期设计阶段模型和体系结构阶段模型。</p>
<h2 id="多媒体基础"><a href="#多媒体基础" class="headerlink" title="多媒体基础"></a>多媒体基础</h2><h4 id="多媒体基础-gt-多媒体技术基本概念"><a href="#多媒体基础-gt-多媒体技术基本概念" class="headerlink" title="多媒体基础&gt;多媒体技术基本概念"></a>多媒体基础&gt;多媒体技术基本概念</h4><p>取样：每隔一定时间间隔，取模拟信号的当前值作为样本，该样本代表了模拟信号在某一时刻的瞬间值。经过一系列的取样，取得连续的样本可以用来代替模拟信号在某一区间随时间变化的值。尼奎斯特取样定理：如果取样速率大于模拟信号最高频率的2倍，则可以用得到的样本中恢复原来的模拟信号。</p>
<p>显示分辨率是指显示器上能够显示出的像素点数目，即显示器在横向和纵向上能够显示出的像素点数目。水平分辨率表明显示器水平方向（横向）上显示出的像素点数目，垂直分辨率表明显示器垂直方向（纵向）上显示出的像素点数目。屏幕能够显示的像素越多，说明显示设备的分辨率越高，现实的图像质量越高。显示深度是指显示器上显示每个像素点颜色的二进制位数。</p>
<p>dpi是Dots Per Inch的缩写，也就是每英寸的像素。</p>
<p>CIF是Common Intermediate Format的简称，即常用的标准化图像格式。在H.323协议簇中，规定了视频采集设备的标准采集分辨率CIF&#x3D;352x288像素。</p>
<h4 id="多媒体基础-gt-MPEG声音信息压缩编码技术"><a href="#多媒体基础-gt-MPEG声音信息压缩编码技术" class="headerlink" title="多媒体基础&gt;MPEG声音信息压缩编码技术"></a>多媒体基础&gt;MPEG声音信息压缩编码技术</h4><p>MP3是流行的数字音乐压缩编码格式，其命名来源于MPEG- 1音、视频压缩编码标准。MPEG- 1的声音压缩编码技术定义了三个编码层（Layer）：layer 1时基础的编码层，layer 2和layer 3的复杂度逐层提高，每个后继的Layer都提供更高的压缩比，但需要更复杂的编码解码器。MP3就是使用MPEG- 1 Audio Layer 3的声音编码。</p>
<h4 id="多媒体基础-gt-媒体的种类（显示媒体）"><a href="#多媒体基础-gt-媒体的种类（显示媒体）" class="headerlink" title="多媒体基础&gt;媒体的种类（显示媒体）"></a>多媒体基础&gt;媒体的种类（显示媒体）</h4><p>通常所说的“媒体（Media）“包括两重含义：一是指信息的物理载体，即存储和传递信息的实体，如手册、磁盘、光盘、磁带以及相关的播放设备等；二是指承载信息的载体，即信息的表现形式（或者说传播形式），如文字、声音、图像、动画和视频等；即CCITT定义的存储媒体和表示媒体。表示媒体又可以分为三种类型：视觉类媒体（如位图图像、矢量图形、图表、符号、视频和动画等）、听觉类媒体（如音响、语音和音乐等）和触觉类媒体（如点、位置跟踪、力反馈和运动反馈等）。视觉和听觉类媒体是信息传播的内容，触觉类媒体是实现实际交互的手段。</p>
<h4 id="多媒体基础-gt-常见多媒体标准"><a href="#多媒体基础-gt-常见多媒体标准" class="headerlink" title="多媒体基础&gt;常见多媒体标准"></a>多媒体基础&gt;常见多媒体标准</h4><p>MPEG即活动图像专家组，MPEG组织制定的各个标准都有不同的目标和应用。</p>
<p>MPEG-1标准用于传输1.5Mbps数据传输率的数字存储媒体运动图像及其伴音的编码。</p>
<p>MPEG-2主要用于实现视&#x2F;音频服务与应用互操作的可能性，是针对标准数字电视和高清晰度电视在各种应用下的压缩方案和系统层的详细规定。</p>
<p>MPEG-4将众多的多媒体应用集成于一个完整的框架内，旨在为多媒体通信及应用环境提供标准的算法及工具，从而建立起一种能被多媒体传输、存储、检索等应用领域普遍采用的统一数据格式。</p>
<p>MPEG-7标准被称为“多媒体内容描述接口”，为各类多媒体信息提供一种标准化的描述，这种描述将与内容本身有关，允许快速和有效的查询用户感兴趣的资料。MPEG-7的目标是支持多种音频和视觉的描述，包括自由文本、N维时空结构、统计信息、客观属性、主观属性、生产属性和组合信息。对于视觉信息，描述将包括颜色、视觉对象、纹理、草图、形状、体积、空间关系、运动及变形等。</p>
<p>JPEG即联合图像专家组，是一种支持8位和24位色彩的压缩位图格式。</p>
<p>H.261又称P*64K标准，其中P为64Bb&#x2F;s的取值范围，是1到30的可变参数，它最初是针对在ISDN上实现电话会议特别是面对面的可视电话和视频会议而设计的。</p>
<p>ADPCM是自适应差分脉冲编码调制的简称，常使用于数字通信系统中，既不是图像编码也不是视频编码的国际标准。</p>
<h2 id="法律法规与标准化"><a href="#法律法规与标准化" class="headerlink" title="法律法规与标准化"></a>法律法规与标准化</h2><h4 id="法律法规与标准化-gt-保护期限"><a href="#法律法规与标准化-gt-保护期限" class="headerlink" title="法律法规与标准化&gt;保护期限"></a>法律法规与标准化&gt;保护期限</h4><p>著作权中修改权、署名权、保护作品完整性都是永久保护的。</p>
<h4 id="法律法规与标准化-gt-知识产权"><a href="#法律法规与标准化-gt-知识产权" class="headerlink" title="法律法规与标准化&gt;知识产权"></a>法律法规与标准化&gt;知识产权</h4><p>著作权、邻接权、专利权、商标权、商业秘密权和集成电路布图设计权属于知识产权的范围。</p>
<p>物权不属于知识产权的范围。</p>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-06-12</span>
            
                <span>该篇文章被 Limit Lau</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/'>
                            笔记整理
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/'>
                            计算机科学与技术
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        

     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            © 2019-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>Do not go gentle into that good night🤡</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
        
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/a11y-dark.min.css">

        
<script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/highlight.min.js"></script>

        
<script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/highlightjs-line-numbers.js"></script>

    


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>